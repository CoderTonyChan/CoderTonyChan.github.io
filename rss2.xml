<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Tony&#39;s Studio</title>
    <link>https://blog.tonystudio.ml/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Tony写字的地方</description>
    <pubDate>Tue, 05 Mar 2019 08:26:38 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>2019博客升级</title>
      <link>https://blog.tonystudio.ml/2019/03/05/2019-blog-feature/</link>
      <guid>https://blog.tonystudio.ml/2019/03/05/2019-blog-feature/</guid>
      <pubDate>Tue, 05 Mar 2019 06:51:24 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;2019年更新一下😊&lt;/p&gt;
&lt;h1 id=&quot;目标功能&quot;&gt;目标功能&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;[x] Disqus换Gitalk&lt;/li&gt;
&lt;li&gt;[x] Google Analytics&lt;/li&gt;
&lt;li&gt;[ ] 标签功能升级&lt;/li&gt;
&lt;li&gt;[ ] 分类功能&lt;/l
        
      
      </description>
      
      <content:encoded><![CDATA[<p>2019年更新一下😊</p><h1 id="目标功能">目标功能</h1><ul><li>[x] Disqus换Gitalk</li><li>[x] Google Analytics</li><li>[ ] 标签功能升级</li><li>[ ] 分类功能</li><li>[ ] 照片墙功能</li></ul><h1 id="disqus换gitalk">Disqus换Gitalk</h1><hr><p>由于在国内上 Disqus 十分糟糕，而且本人社交基本在GitHub上，故改成Gitalk</p><h2 id="集成-gitalk">集成 Gitalk</h2><hr><p>可参考文档 <a href="https://github.com/gitalk/gitalk" target="_blank" rel="noopener">Gitalk</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Gitalk 评论 start  --&gt;</span><br><span class="line">&#123;% if site.gitalk.enable %&#125;</span><br><span class="line">&lt;!-- Link Gitalk 的支持文件  --&gt;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt;</span><br><span class="line">&lt;script src=&quot;https://unpkg.com/gitalk@latest/dist/gitalk.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var gitalk = new Gitalk(&#123;</span><br><span class="line">        clientID: `Github Application clientID`,</span><br><span class="line">        clientSecret: `Github Application clientSecret`,</span><br><span class="line">        repo: `存储你评论 issue 的 Github 仓库名`,</span><br><span class="line">        owner: &apos;Github 用户名&apos;,</span><br><span class="line">        admin: [&apos;Github 用户名&apos;],</span><br><span class="line">        id: location.pathname,</span><br><span class="line">    &#125;);</span><br><span class="line">    gitalk.render(&apos;gitalk-container&apos;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br><span class="line">&lt;!-- Gitalk end --&gt;</span><br></pre></td></tr></table></figure><h2 id="创建-github-application">创建 Github Application</h2><hr><p>如果没有 <a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">点击这里申请</a>，<code>Authorization callback URL</code> 填写当前使用插件页面的域名。</p><h2 id="创建issue">创建issue</h2><hr><p>当你用 github 帐号登录（管理员），并且第一次加载该会比较慢，因为第一次加载会自动在你 repo 的仓库下创建对应 issue。</p><p>当然，你也可以手动创建issue作为 gitalk评论容器。只要有 Gitalk 标签 和 id 对应标签就可以。</p><p>Gitalk 需要在管理员在登录状态下点开每篇文章的页面才会创建对应的 issue。</p><p>解决方案如下 :<br><a href="https://draveness.me/git-comments-initialize" target="_blank" rel="noopener">自动初始化 Gitalk 和 Gitment 评论</a></p><h1 id="google-analytics">Google Analytics</h1><hr><h1 id="标签功能升级">标签功能升级</h1><hr><h1 id="分类功能">分类功能</h1><hr><h1 id="照片墙功能">照片墙功能</h1><hr><hr><p>Reference：</p><blockquote><p>GitHub Repo：<a href="https://github.com/CoderTonyChan/CoderTonyChan.github.io" target="_blank" rel="noopener">Tony Studio</a></p><p>Follow: <a href="https://github.com/CoderTonyChan" target="_blank" rel="noopener">CoderTonyCHan · GitHub</a></p></blockquote>]]></content:encoded>
      
      <comments>https://blog.tonystudio.ml/2019/03/05/2019-blog-feature/#disqus_thread</comments>
    </item>
    
    <item>
      <title>七牛云备份命令</title>
      <link>https://blog.tonystudio.ml/2019/02/26/qiniu/</link>
      <guid>https://blog.tonystudio.ml/2019/02/26/qiniu/</guid>
      <pubDate>Tue, 26 Feb 2019 02:51:24 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;由于最近博客搬家, 使用了七牛云&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/16996753/53394471-5c8e6380-39da-11
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>由于最近博客搬家, 使用了七牛云</p></blockquote><p><img src="https://user-images.githubusercontent.com/16996753/53394471-5c8e6380-39da-11e9-9d32-b5507474259b.png" alt="image"></p><h1 id="批量上传">批量上传</h1><hr><p>blog.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"src_dir"</span>: <span class="string">"/Users/tonychan/Pictures/qiniu"</span>,</span><br><span class="line"><span class="attr">"bucket"</span>: <span class="string">"tonystudio-ml"</span>,</span><br><span class="line"><span class="attr">"rescan_local"</span>: <span class="literal">true</span>,</span><br><span class="line"><span class="attr">"skip_suffixes"</span>: <span class="string">".DS_Store"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qshell qupload blog.json</span><br></pre></td></tr></table></figure><h1 id="批量下载">批量下载</h1><hr><pre><code class="language-shell">qshell listbucket tonystudio-ml  &gt; listcat list | awk -F ' ' ' {print &quot;http://pn9jzw2t9.bkt.clouddn.com/&quot;$1}' &gt; urlList</code></pre><p>将tonystudio-ml 和 <a href="http://pn9jzw2t9.bkt.clouddn.com" target="_blank" rel="noopener">http://pn9jzw2t9.bkt.clouddn.com</a> 改成自己的变量即可</p><hr><p>Reference：</p><blockquote><p>GitHub Repo：<a href="https://github.com/CoderTonyChan/CoderTonyChan.github.io" target="_blank" rel="noopener">Tony Studio</a></p><p>Follow: <a href="https://github.com/CoderTonyChan" target="_blank" rel="noopener">CoderTonyCHan · GitHub</a></p></blockquote>]]></content:encoded>
      
      <comments>https://blog.tonystudio.ml/2019/02/26/qiniu/#disqus_thread</comments>
    </item>
    
    <item>
      <title>2018 年总结</title>
      <link>https://blog.tonystudio.ml/2019/01/01/2018-summary/</link>
      <guid>https://blog.tonystudio.ml/2019/01/01/2018-summary/</guid>
      <pubDate>Mon, 31 Dec 2018 16:11:24 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;不知不觉已经到了9102年了，回顾过去的2018，自己也有不少的收获。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://pn9jzw2t9.bkt.clouddn.com/2019/2018-summary.0.png&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>不知不觉已经到了9102年了，回顾过去的2018，自己也有不少的收获。</p></blockquote><p><img src="http://pn9jzw2t9.bkt.clouddn.com/2019/2018-summary.0.png" alt=""></p><h1 id="2018总结">2018总结</h1><hr><p>2018慢慢体验到了苹果，Google，腾讯的伟大的。慢慢拾起苹果的各种效率应用，比如邮件、日历、提醒事项、备忘录、捷径等等。还有离不开iPhone的生态。在设计行业和影音行业的领先，比如发布了iMac Pro，和iPad Pro都是针对设计行业。</p><p>Google的云服务基本没任何对手。YouTube，Google Photos，Google Maps暂时没任何对手。</p><p>后慢慢了解到社交的重要性，虽然腾讯不是最牛的，但是是微信让我理解到这一点。社交可以做任何事情，社交 + 教育 / 社交 + 金融 / 社交 + 电商 。</p><p>因为社交的载体是人，就有了无限的可能性，而互联网最重要的是内容，内容正是从人而来，这就应了习大大的口号：“人才是第一资源，创新是第一动力”。</p><p>对于我个人成长，我需要利用好这些工具去更快成长！</p><p>2018年，我接触到很多软件工程外其他领域，比如产品设计，平面设计，摄影师，录像师，健身教程，花式溜冰，炒菜教程等等。</p><p>通过观看各种各样的教程，更加发现，名师的重要性。再次体验到人在这个环节的重要性。“你爸是谁”既然存在，就非常合理。</p><p>以下通过几个关键词去总结过去一年。</p><h1 id="健康">健康</h1><hr><h2 id="keep">Keep</h2><hr><p>总结报告</p><p>Keep的课程分类<br><img src="https://user-images.githubusercontent.com/16996753/53464300-aaf83c80-3a84-11e9-9eec-84952cdfe77a.png" alt="22dbb8df-7f7b-4bae-9276-efb80908933a"><br><img src="https://user-images.githubusercontent.com/16996753/53464304-b0ee1d80-3a84-11e9-8f68-1eab6ef90e88.png" alt="c3383a41-76e9-45d6-8bcd-18afe9740b28"></p><p>但是也没真正减肥，只是能保证以后没这么多病。</p><h2 id="滑冰️">滑冰⛸️</h2><hr><p>夏天的新尝试，但是现在几乎都忘了。</p><h1 id="读书电影">读书/电影</h1><hr><h2 id="豆瓣">豆瓣</h2><hr><p><a href="https://www.douban.com/standbyme/2018?uid=103961302&amp;dt_dapp=1" target="_blank" rel="noopener">总结报告</a></p><p><img src="http://pn9jzw2t9.bkt.clouddn.com/2019/2018-summary-1.png" alt=""></p><p><img src="http://pn9jzw2t9.bkt.clouddn.com/2019/2018-summary-2.png" alt=""></p><p><img src="http://pn9jzw2t9.bkt.clouddn.com/2019/2018-summary-3.png" alt=""></p><p><img src="http://pn9jzw2t9.bkt.clouddn.com/2019/2018-summary-4.png" alt=""></p><p><img src="http://pn9jzw2t9.bkt.clouddn.com/2019/2018-summary-5.png" alt=""></p><h2 id="kindle">Kindle</h2><hr><p>购入了Kindle，看更多的书籍</p><h1 id="平面设计摄影师录像师">平面设计/摄影师/录像师</h1><hr><p>艺术，使人脱颖而出。</p><p>我们不只是用相机拍照，我们带到摄影中去的是所有我们读过的书、看过的电影、听过的音乐、走过的路、爱过的人。</p><h2 id="平面设计">平面设计</h2><hr><p>接触到了wacom全线产品，对比iPad Pro和Surface系列。</p><p>也了解一些绘图的基本功。</p><p>学习了一些素描的基础，但是没有坚持下去。</p><h2 id="摄影师">摄影师</h2><hr><p>A7 + 55 1.8/28 f2/85 1.8 的使用</p><p>理论基本上全部看完了，什么构图，调色，机器的使用，LR/PS教程。</p><p>但是能拿出手的就只有漫展和日本旅行的照片，平时并没有作为摄影师的素养。</p><h2 id="录像师">录像师</h2><hr><p>基本上看完了Final Cut Pro X的所有基本操作。还购入了大疆的OSMO Mobile 2。</p><p>但是一个像样的视频也没有创作出来，基本是demo。</p><h1 id="金融">金融</h1><hr><p>业余时间也读了一些经济学相关的教材，了解经济学的知识对作者的影响还是比较大的，虽然很多经济学的结论都能够根据直觉推测出来，但是有一些现象和规则学习起来还是非常有趣。</p><p>明年可能还是会花一些时间来阅读经济学相关的书籍，同时也希望减少技术书籍的阅读量，目前市面上真正值得多次阅读的技术书籍真的非常的少，想要静下心来好好学习一下更抽象的知识，帮助自己在软件设计上的理解更进一步。</p><h1 id="生活">生活</h1><h2 id="小公主1岁">小公主1岁</h2><hr><p>通过iPhone的照片应用，的确留下不是珍贵的片段。</p><p>小孩教育的思考：</p><p>魔都娃标配兴趣班列表：</p><ul><li>一门乐器，以钢琴为首，小提琴、架子鼓，长笛、古筝等民乐为辅，再佐以黑管、大提琴、古琴等小众乐器等；</li><li>一门运动，游泳最佳，足球、网球、篮球、轮滑、跆拳道等为辅，再佐以冰球、剑道、高尔夫等小众高端运动项目；</li><li>一门艺术，以画画、舞蹈为首，书法、国学、其他手工课程为辅；</li><li>一门学科，以英语、奥数（思维／数学）为主，大部分是两门都上，再辅以乐高、机器人等其他高冷课程；</li></ul><h2 id="10月日本之旅">10月日本之旅</h2><hr><p>一些照片</p><h1 id="游戏">游戏</h1><hr><ul><li>怪物猎人世界</li><li>机战X</li><li>奥德赛</li><li>Let’s Go 皮卡超</li></ul><h1 id="社交网络">社交网络</h1><hr><ul><li>RSSHub</li><li>YouTube</li><li>BiliBili</li><li>Telegram</li><li>好友圈</li><li>博客</li><li>Facebook</li><li>Ins</li><li>微博</li></ul><h1 id="个人项目">个人项目</h1><hr><ul><li>GCP的梯子</li><li>GitHub的PR</li><li>自建RSS</li></ul><h2 id="博客">博客</h2><hr><p>培养写作的能力。</p><h1 id="未来技术趋势">未来技术趋势</h1><hr><ul><li>分布式</li><li>区块链</li><li>云原生（k8s）</li></ul><hr><p>Reference：</p><blockquote><p>GitHub Repo：<a href="https://github.com/CoderTonyChan/CoderTonyChan.github.io" target="_blank" rel="noopener">Tony Studio</a></p><p>Follow: <a href="https://github.com/CoderTonyChan" target="_blank" rel="noopener">CoderTonyCHan · GitHub</a></p></blockquote>]]></content:encoded>
      
      <comments>https://blog.tonystudio.ml/2019/01/01/2018-summary/#disqus_thread</comments>
    </item>
    
    <item>
      <title>FFmpeg命令</title>
      <link>https://blog.tonystudio.ml/2018/11/06/FFmpeg/</link>
      <guid>https://blog.tonystudio.ml/2018/11/06/FFmpeg/</guid>
      <pubDate>Tue, 06 Nov 2018 00:11:24 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;最近研究音视频的下载, 用上FFMpeg&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/16996753/53394471-5c8e6380-39d
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>最近研究音视频的下载, 用上FFMpeg</p></blockquote><p><img src="https://user-images.githubusercontent.com/16996753/53394471-5c8e6380-39da-11e9-9d32-b5507474259b.png" alt="image"></p><h1 id="mp4分割">mp4分割</h1><hr><p>由于iCloud的上传只能上传15min以内的,所有有了这个需求</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>!/bin/bash</span><br><span class="line">startTime=0</span><br><span class="line">endTime=0</span><br><span class="line">length=11530</span><br><span class="line">i=0</span><br><span class="line">file=$1</span><br><span class="line">while [ $endTime -le $length ]; do</span><br><span class="line"><span class="meta">#</span>statements</span><br><span class="line">    i=$[$i+1]</span><br><span class="line">    endTime=$[$startTime+840]</span><br><span class="line">    ./ffmpeg -ss $startTime -to $endTime -accurate_seek -i $1 -codec copy -avoid_negative_ts 1 $&#123;file%.*&#125;$i.mp4</span><br><span class="line">    startTime=$[endTime]</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h1 id="flv2mp4">FLV2MP4</h1><hr><pre><code class="language-shell">for file in *.mp4do    ./ffmpeg -i $file ${file%.mp4}v2.mp4done</code></pre><h1 id="m3u8-dl">m3u8-dl</h1><hr><p>不想用工具的时候可以凑合使用, 更加推荐 you-get , YouTube-dl等更加好的工具 , 或者使用gui工具, 如Downie3</p><pre><code class="language-shell">ffmpeg -i &quot;http://video.qqdaiguaxitong.com:8091/9720180601/972018063017/650kb/hls/index.m3u8&quot; -c copy video1.mp4</code></pre><p>这种方法虽然能用 但是很耗时间</p><hr><p>文中所有代码如下</p><blockquote><p>Source: <a href="https://github.com/CoderTonyChan/shell-repo" target="_blank" rel="noopener">CoderTonyChan/shell-repo</a></p></blockquote><hr><p>Reference：</p><blockquote><p>GitHub Repo：<a href="https://github.com/CoderTonyChan/CoderTonyChan.github.io" target="_blank" rel="noopener">Tony Studio</a></p><p>Follow: <a href="https://github.com/CoderTonyChan" target="_blank" rel="noopener">CoderTonyCHan · GitHub</a></p><p>Source: <a href="https://github.com/CoderTonyChan/shell-repo" target="_blank" rel="noopener">CoderTonyChan/shell-repo</a></p></blockquote>]]></content:encoded>
      
      <comments>https://blog.tonystudio.ml/2018/11/06/FFmpeg/#disqus_thread</comments>
    </item>
    
    <item>
      <title>wireshark 入门教程</title>
      <link>https://blog.tonystudio.ml/2018/09/05/wireshark-tutorial/</link>
      <guid>https://blog.tonystudio.ml/2018/09/05/wireshark-tutorial/</guid>
      <pubDate>Wed, 05 Sep 2018 02:51:24 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;网络抓包是个基础技能，对于网络协议的掌握有一定的要求。iOS上实现网络抓包可以用Charles（针对http和https），tcpdump（快速分析网络包），和Wireshare。之前写过一篇介绍tcpdump抓包的入门文章，和tcpdump相比，
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>网络抓包是个基础技能，对于网络协议的掌握有一定的要求。iOS上实现网络抓包可以用Charles（针对http和https），tcpdump（快速分析网络包），和Wireshare。之前写过一篇介绍tcpdump抓包的入门文章，和tcpdump相比，Wireshark提供丰富的GUI交互，而且能分析所有的网络协议，关键还是免费的，掌握好Wireshark就能应付绝大部分需要分析网络协议的场景了。</p></blockquote><h1 id="安装初识">安装初识</h1><hr><p>Wireshark提供Mac版本，可以从官网下载安装，到这篇博客为止最新版本应该是2.2.1。安装好之后打开的第一个界面如下：</p><img width="500" alt="6acb6917-0d00-4673-ac57-f6200a853865" src="https://user-images.githubusercontent.com/16996753/53470399-827c3c80-3a9c-11e9-8bb5-37f44cfbd35b.png"><p>Wireshark在第一个界面就把当前系统所包含的网卡列出来了，直接点击任何一项就可以开始监听通过该网卡的所有网络流量。<br>当我们把iPhone通过usb连接macbook时，Wireshark并不能直接监听通过iPhone的网络流量，需要通过一个系统程序在我们的Mac系统上，建立一个映射到iPhone的虚拟网卡，在terminal中输入如下命令即可：</p><img width="500" alt="10f399c5-1527-46eb-adcf-be4d4a8425f5" src="https://user-images.githubusercontent.com/16996753/53470411-8c9e3b00-3a9c-11e9-8180-1dc405b7fa17.png"><p>格式是rvictl -s [设备udid]，设备的udid可以通过itunes或者itools获取，执行命令之后Wireshark能立即识别新增加的rvi0网卡，也就是上图中高亮的部分，双击rvi0这一项，Wireshare即进入如下界面开始监听iPhone设备上的所有流量。</p><img width="500" alt="cd63d159-765f-437f-974f-19a17e3c05f6" src="https://user-images.githubusercontent.com/16996753/53470427-97f16680-3a9c-11e9-8ac6-49af3ac74981.png"><p>此时，启动iPhone上的任意App，只要有网络流量产生，对应的网络包都会在Wireshark上述的列表中展示出来。<br>Wireshark的流量监控界面主要分为四块，由上至下第一部分（标号为1）是工具栏，通过工具栏我们可以控制监控的行为，比如开始抓包，停止抓包，重新开始抓包，以及在包之间跳转等等。工具栏的底部有个输入框，可以让我们手动输入包的过滤条件，这部分对于熟练使用Wireshark抓包非常重要，后面会详细的讲解。<br>第二部分（标号为2）是历史流量包列表展示界面，这里展示的是从抓包开始，所有通过我们iPhone设备的流量。列表界面不同的包有不同的颜色，Wireshark通过颜色来区分包的类型，对于特定场景快速识别目标流量非常有用，后面也会专门讲解。<br>第三部分（标号为3）是单个包的详细信息展示面板，我们在第二部分选中的网络包在这一部分会将其结构以可阅读的文本形式展示出来，要正确阅读这一部分的信息需要对tcp/ip协议有一定的掌握。<br>第四部分（标号为4）是单个包的二进制流信息展示面板，这一部分展示的信息是包的原始数据，也是一个网络包所包含内容的真实展现，我们在第三部分多选中的协议头，都会在这一部分以同步高亮的形式标记出来。这一部分的展示是为了让我们对包的真实内容做直观的判断，能具体到单个byte。<br>初步认识上述四块主要面板之后，可以尝试开始分析网络包，在开始分析网络包之前，先要对网络包有个大致的概念。</p><h1 id="网络包结构">网络包结构</h1><hr><p>我们最初学习网络协议的时候，无论是OSI七层模型，还是经典的TCP/IP五层结构，都是以下图中的左边部分的形式展示的。</p><img width="500" alt="1b6e7c66-5253-48b7-9b98-291dd966219c" src="https://user-images.githubusercontent.com/16996753/53470437-9cb61a80-3a9c-11e9-85ee-d5645e7af178.png"><p>这是一种经典的分层架构，确实也符合网络协议设计上的思路，但却不能表达网络包真实的包含关系。上图右边部分是我所绘制的一个包结构示意图。在我看来，这种洋葱式的结构更符合网络包的真实形态。Application是最内层的payload，除了Application这一层之外，其他层都是用自己这一层的协议header+所包含那一层的payload。可以用如下公式表示：</p><p>TCP Layer = TCP Header + Application Payload</p><p>IP Layer = IP Header + TCP Payload</p><p>…</p><p>我们分析每个网络包的时候要能理解每一个包它所代表的抽象含义，再进一步将相关联的包串联起来，形成一次完整的网络会话。</p><h1 id="分析包结构">分析包结构</h1><hr><p>对于iOS程序员来说，我们绝大部分的流量分析都集中在HTTP或者基于TCP的socket长连接。从这一层面来说，和我们最贴近的三层是应用层(http)，传输层(tcp or udp)，网络层(ip)。<br>对于应用层来说主要是http协议的学习，对于http request和response格式的阅读，比如下图表示的一个http request包：</p><img width="500" alt="a2873532-9e47-4a03-ab95-45599923129b" src="https://user-images.githubusercontent.com/16996753/53470438-a049a180-3a9c-11e9-920f-c74bca0b946b.png"><p>Packet详情面板以符合http协议的表述，将header中各个field清晰的罗列出来了，阅读起来很方便。<br>传输层我们应用较多的是tcp，这一层的阅读主要是tcp header的学习：</p><img width="500" alt="d7069508-f4e1-4813-b31b-3d91f8636435" src="https://user-images.githubusercontent.com/16996753/53470444-a3dd2880-3a9c-11e9-9c5a-35f5f436b0b9.png"><p>典型的tcp header一般长度为20个字节，将这20个字节逐一学习一遍就可以分析大部分的tcp流量了。<br>网络层的分析主要是针对于IP Header，header结构如下：</p><img width="500" alt="eba25723-c341-44c3-a4fd-7c2730584cbc" src="https://user-images.githubusercontent.com/16996753/53470446-a6d81900-3a9c-11e9-93b1-0b2036865375.png"><p>这其中IP Header第十三个字节各个filed的理解，对于我们分析tcp流量的起始和结束尤其有用，典型的IPV4 Header也是20个字节，梳理一遍就可以分析IP包了。<br>所以对于包结构的分析关键在于三个知识点的学习：http header, tcp header, ip header，这么一看好像也没多少东西 ;)</p><h1 id="使用filter过滤包">使用Filter过滤包</h1><hr><p>使用Wireshark和使用Charles最大的区别在于，Charles只捕获HTTP流量，而Wireshark捕捉的是经过目标网卡所有的流量，流量包可以在几秒内膨胀到难以阅读的数量，所以此时我们需要使用Filter来做包的过滤，Filter规则定的越细，剔除掉的干扰信息就越多，分析起来就越快。</p><p>Wireshark的Filter分为两种，一种为Capture Filter，另一种是Display Filter。</p><p>Capture Filter出现在初始界面，在网卡列表的上方有个输入框，允许我们输入capture filter，一旦输入了特定的capture规则，Wireshark就只捕获符合该规则的流量包了。</p><img width="500" alt="ce1a622b-1312-46c8-a7c4-90f3cc9615da" src="https://user-images.githubusercontent.com/16996753/53470448-a9d30980-3a9c-11e9-9ea5-1b705fea4af2.png"><p>Display Filter出现在流量监控界面，在工具栏的下方有个输入框，允许我们输入display filter，display filter只是从界面上过滤掉不符合规则的包，Wireshark实际上还是监听了这些包，一旦去掉display filter，所有的包又会出现在同一界面。</p><img width="500" alt="33749cab-566e-47e0-8aed-9d516644f1ff" src="https://user-images.githubusercontent.com/16996753/53470454-ad669080-3a9c-11e9-8016-05bd1e5a5e97.png"><p>Capture Filter的规则和我们平常使用tcpdump的filter语法是一致的，比如为了只监控http的流量，我们可以先在初始化界面选中rvi0网卡，再在capture filter输入框里输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//只捕获HTTP流量</span><br><span class="line">port 80 or port 443</span><br></pre></td></tr></table></figure><p>回车之后Wireshark就开始监控我们iPhone上所有的http和https流量了 ，非常简单，我们还可以使用其他的capture filter来捕获特定的流量，比如想分析DNS解析过程，可以使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//只捕获DNS流量</span><br><span class="line">port 53</span><br></pre></td></tr></table></figure><p>比如只想捕获和特定服务器相关的流量:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//只捕获和特定主机的流量</span><br><span class="line">host 171.10.191.10</span><br></pre></td></tr></table></figure><p>Display Filter的语法是由Wireshark自定义的，和Capture filter的语法不能混用。比如我们只想看某个主机的流量，可以使用如下Display Filter：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip.addr==171.10.191.10</span><br></pre></td></tr></table></figure><p>如果只看http或者https的流量，可以用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcp.port == 80 || tcp.port == 443</span><br></pre></td></tr></table></figure><p>更多的语法规则可以查看Wireshark官方文档，Wireshark实际上提供了便捷的UI操作帮助我们来书写Display Filter，在Display Filter输入框的最右边有个Expression按钮，点击之后可以弹出如下界面：</p><img width="500" alt="4af664f7-0694-43c9-807e-1d3f2eb54a11" src="https://user-images.githubusercontent.com/16996753/53470458-b22b4480-3a9c-11e9-81b5-3dd647ea3b39.png"><p>Display Filter的语法本质上是个等是关系描述，我们可以在search当中输入我们感兴趣的协议比如http，再在展开的协议头里选择我们的条件比如http.host，最后设置Relation和Value就可以生成一个Display Filter条件了。</p><h1 id="包颜色规则">包颜色规则</h1><hr><p>Wireshark在大多数时候捕获的包数量都远超我们感兴趣的数量，而且各个连接的包都混杂在一起，为了方便我们识别不同的连接会话，Wireshark默认使用一种着色规则帮助我们来进行包类型区分。</p><p>具体的规则可以通过菜单View-&gt;Coloring Rules…查看，默认规则如下：</p><img width="500" alt="4d3b2980-dfd4-4a1a-9b8b-99dfc1cd8eb1" src="https://user-images.githubusercontent.com/16996753/53470468-b5becb80-3a9c-11e9-9338-4ec6fc8f4bdc.png"><p>这里有个小技巧，如上图所示，我只将我感兴趣的协议包上了色，集中在http，tcp，udp包，这样分析起来更加直观。比如根据上图的规则，tcp三次握手中的Sync包是使用灰色标记的，这样我就可以在下图的包中迅速定位一次tcp连接的开始包位置：</p><img width="500" alt="236e7e35-ab3d-4be1-a911-8844e5187b78" src="https://user-images.githubusercontent.com/16996753/53470472-b8b9bc00-3a9c-11e9-9439-c652a28ac418.png"><p>当然，包的颜色也可以按照自己的视觉习惯进行定制，我个人习惯把Sync包和FIN包设置一个高亮的颜色，方便判断一次HTTP会话的起始和结束。</p><h1 id="流量跟踪">流量跟踪</h1><hr><p>Wireshark默认情况下将不同网络连接的流量都混在一起展示，即使给不同协议的包上色之后，要单独查看某个特定连接的流量依然不怎么方便，我们可以通过Wireshark提供的两种方式来实现这个目标。</p><p>方式一：Follow Stream</p><p>当我们选中某个包之后，右键弹出的菜单里，有个选项允许我们将当前包所属于的完整流量单独列出来，如下图：</p><img width="500" alt="4f0320fb-6bb0-4161-b5f1-8e5789775a6d" src="https://user-images.githubusercontent.com/16996753/53470484-bc4d4300-3a9c-11e9-9a94-80b77723b876.png"><p>Wireshark支持我们常见的四种Stream，TCP，UDP，HTTP，SSL。比如我们选中Follow TCP Stream之后可以得到如下的详细分析输出（样本为监控iPhone手机的流量）：</p><img width="500" alt="44c54654-9f31-4b9e-9db9-8ba21995eef0" src="https://user-images.githubusercontent.com/16996753/53470489-bfe0ca00-3a9c-11e9-82e4-9cec23966158.png"><p>上图中将iPhone和Server之间某次的连接流量完整的呈现出来，包括iPhone发送了多少个包，Server回了多少个包，以及iPhone上行和下行的流量，还提供流量编解码选择，文本搜索功能等。</p><p>方式二：Flow Graph</p><p>Flow Graph可以通过菜单Statistics-&gt;Flow Graph来生成，这样我们可以得到另一种形式的流量呈现：</p><img width="500" alt="fc19eb0d-15fd-42f5-a729-e22c02c22ced" src="https://user-images.githubusercontent.com/16996753/53470491-c2dbba80-3a9c-11e9-911a-f6de53eb1ad2.png"><p>和Follow Stream不同的是我们获取到的是完整的流量，从上图中可以看出从10.136.66.127(我的iPhone手机IP地址)发出的流向多个服务器的网络流量，包括DNS解析和SSL安全握手等。当然我们也可以在上图中下方的操作区域做进一步的过滤，可以使用Display Filter做进一步的流量定位。</p><p>Follow Stream更适合分析针对某一个服务器地址的流量，而Flow Graph更适合分析某个App的整体网络行为，包含从DNS解析开始到和多个服务器交互等。</p><p>其实Statistics菜单下还有更多的图表分析模式，可以根据不同的分析目标来选择，比如Statistics-&gt;HTTP-&gt;Requests可以得到如下按主机分门别类的HTTP请求分析图，和收费的Charles的展示结果类似。</p><img width="500" alt="8bcde133-c012-4262-a785-8a822b7aebc7" src="https://user-images.githubusercontent.com/16996753/53470496-c5d6ab00-3a9c-11e9-9e14-fa60eb62d214.png"><h1 id="https包分析">HTTPS包分析</h1><hr><p>介绍完使用方式再来实际分析下HTTPS的流量。下图是我使用Wireshark在iPhone上抓包知乎App网络请求的结果：</p><img width="500" alt="4af664f7-0694-43c9-807e-1d3f2eb54a11" src="https://user-images.githubusercontent.com/16996753/53470501-c8d19b80-3a9c-11e9-9d83-28b146f1f0c4.png"><p>当我使用Follow TCP Stream之后，一次完整的HTTPS会话流量就被单独过滤出来了，第一步先分析包列表界面。<br>通过高亮颜色找到会话的其实Sync包，继而可以快速的定位到HTTP建立连接之初的tcp三次握手所产生的三个包：</p><p>Sync： iPhone发送Sync。</p><p>Sync+Ack： Server发送Sync+Ack。</p><p>Ack： iPhone Ack。</p><p>三次握手之后是ssl handshake，ssl handshake分为以下几步：</p><p>Client Hello</p><p>这一个包是ssl握手的起始包，客户端（我的iPhone）会携带当前会话所依赖的一些关键信息：使用的tls版本（当前为tls1.2），上次的Session ID（如果可以session重用，就可以避免当前这次的安全握手），客户端所支持的加密算法套件（从下图中可以看出可以从22个suites里面挑选）等。</p><img width="500" alt="9d04e8e8-9b84-4983-a203-3ca05cf9188d" src="https://user-images.githubusercontent.com/16996753/53470507-cbcc8c00-3a9c-11e9-9954-4fd365174e69.png"><p>Server Hello</p><p>Server Hello这个包带上服务器这一端的一些信息，比如Server所选择的tls版本，或者带上可以重用的Session ID避免重新握手，在Client传过来的Cipher Suites当中挑选一个Cipher Suite进行后续的安全通话等。</p><img width="500" alt="88434006-295c-4a12-814b-45f102b8ea3a" src="https://user-images.githubusercontent.com/16996753/53470514-ce2ee600-3a9c-11e9-82a7-eebe4a717f4f.png"><p>Server 下发Certificate</p><p>Server同时会下发自己的Certificate，如下图所示：</p><img width="500" alt="1113cc9c-bd09-4a2d-987c-d7f63df3ea4c" src="https://user-images.githubusercontent.com/16996753/53470519-d129d680-3a9c-11e9-9e56-6589ce9b43f9.png"><p>从包列表界面可以看出，Certificate（大小为2407个bytes）这个包由于超过了1440个字节，被拆成了2个包，所以我们可以在包Info里面看到[TCP segment of a reassembled PDU]，我们使用Wireshark抓包的时候经常会看到reassembled PDU，出现这种情况是因为包太大，超过了MSS，需要拆成两个来发送。<br>接下来几个包是Client和Server基于上面交换的信息协商最后使用的密钥。</p><p>Server Key Exchange</p><p>Client Key Exchange</p><p>Change Cipher Spec</p><p>…</p><p>Send Application Data</p><p>各个包里面所包含的详细内容分析涉及到非对称加密算法的相关知识，这里就不展开了，使用Wireshark可以将整个HTTPS的握手过程非常清晰的展现出来，感兴趣的同学可以阅读这篇文章。<br>当然大部分时候我们需要分析iPhone上HTTPS流量里的具体包内容，Wireshark虽然支持配置RSA私钥，但我们没办法直接获取iPhone设备上各个App所使用的私钥，这种场景下我们一般使用MITM（Man In The Middle）中间人攻击来破解HTTPS包内容，收费工具Charles可以通过代理的方式来实现此功能，免费版抓包工具mitmproxy同样也可以，Charles的使用教程比较多了，后续我们会再写一篇mitmproxy的教程介绍如何使用破解调试HTTPS的流量。<br>结束语</p><p>Wireshark就介绍到这里，现在在iPhone上抓包的方式有很多，有面向所有协议的tcpdump和Wireshark，也有针对HTTP的Charles和mitmproxy，无论使用哪个工具，前提都是我们需要对网络协议有全面的认识，所以在学习使用这些工具的同时，要持续深入的学习网络协议知识。</p><h1 id="抓包例子">抓包例子</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ rvictl -s c85646a786f30eaea5732c806c586f3ed7fae11c</span><br><span class="line">// capture filter</span><br><span class="line">host==59.36.6.53 ||  host==192.168.3.65</span><br><span class="line">// Filter  </span><br><span class="line">ip.addr==59.36.6.53 ||  ip.addr==192.168.3.65</span><br></pre></td></tr></table></figure><h2 id="抓websocket">抓websocket</h2><p><img src="https://user-images.githubusercontent.com/16996753/53471087-8d37d100-3a9e-11e9-8fdb-1a0721f49331.png" alt="wireshark1"></p><h2 id="字节解析器">字节解析器</h2><p><img src="https://user-images.githubusercontent.com/16996753/53471105-9c1e8380-3a9e-11e9-9492-e2a07a796a3d.png" alt="056b5218-f16f-453b-bba8-1b7abdabd7ca"></p><h2 id="完整的https请求">完整的HTTPS请求</h2><p><img src="https://user-images.githubusercontent.com/16996753/53471113-9f197400-3a9e-11e9-9563-0d6cff8695dd.png" alt="6c6f2aba-dc2c-4d1c-886b-eac90941ee1f"></p><h2 id="证书超过1400-做了分包">证书超过1400 做了分包</h2><p><img src="https://user-images.githubusercontent.com/16996753/53471119-a2acfb00-3a9e-11e9-99a1-23438dd9ad8a.png" alt="86e8c06f-4b19-4ee7-a1d2-b02c26e969ce"></p><h1 id="流量跟踪功能测试">流量跟踪功能测试</h1><hr><h2 id="追踪-http流">追踪 HTTP流</h2><p><img src="https://user-images.githubusercontent.com/16996753/53471123-a6408200-3a9e-11e9-9936-ba3f5ee05cfe.png" alt="shark2"></p><h2 id="追踪tcp为http服务的">追踪TCP（为HTTP服务的）</h2><p><img src="https://user-images.githubusercontent.com/16996753/53471128-a9d40900-3a9e-11e9-90b0-dfca3ff79f61.png" alt="tcp"></p><h2 id="追踪ssl-和-tcp一样">追踪SSL （和 TCP一样）</h2><p><img src="https://user-images.githubusercontent.com/16996753/53471131-accef980-3a9e-11e9-8159-2322ac3e67a4.png" alt="09e86bc8-a1ac-49f3-9701-79c6f7d1463c"></p><h2 id="追踪websocket-连接">追踪WebSocket 连接</h2><p><img src="https://user-images.githubusercontent.com/16996753/53471135-b0628080-3a9e-11e9-8857-08576b8ac399.png" alt="00575db6-982e-4f40-9e10-23ac6dc7f6b0"></p><h2 id="websocket的开始和结束">Websocket的开始和结束</h2><p><img src="https://user-images.githubusercontent.com/16996753/53471136-b3f60780-3a9e-11e9-86e9-68f917072b5b.png" alt="websocket"></p><h1 id="wireshark常用过滤规则">wireshark常用过滤规则</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// GET包</span><br><span class="line">http.request.method == “GET” &amp;&amp; http contains “Host: “</span><br><span class="line"></span><br><span class="line">tcp.len &gt;= 7   指的是ip数据包(tcp下面那块数据),不包括tcp本身</span><br><span class="line">ip.src eq 10.175.168.182</span><br></pre></td></tr></table></figure><hr><p>Reference：</p><blockquote><p>GitHub Repo：<a href="https://github.com/CoderTonyChan/CoderTonyChan.github.io" target="_blank" rel="noopener">Tony Studio</a></p><p>Follow: <a href="https://github.com/CoderTonyChan" target="_blank" rel="noopener">CoderTonyCHan · GitHub</a></p></blockquote>]]></content:encoded>
      
      <comments>https://blog.tonystudio.ml/2018/09/05/wireshark-tutorial/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Filza Summary</title>
      <link>https://blog.tonystudio.ml/2018/08/08/ios-Filza/</link>
      <guid>https://blog.tonystudio.ml/2018/08/08/ios-Filza/</guid>
      <pubDate>Wed, 08 Aug 2018 02:18:22 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;Filza File Manager 是iOS 系统的一款多功能文件管理器，需要越狱后安装，功能强大，使用简单，可以查看所有文件，是一款真正意义上的iOS 文件管理器，兼容iOS 7~iOS 11 系统，适用于iPhone、iPad、iPod To
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>Filza File Manager 是iOS 系统的一款多功能文件管理器，需要越狱后安装，功能强大，使用简单，可以查看所有文件，是一款真正意义上的iOS 文件管理器，兼容iOS 7~iOS 11 系统，适用于iPhone、iPad、iPod Touch。</p></blockquote><hr><h1 id="filza-file-manager简介">Filza File Manager简介</h1><p>Filza File Manager 主要特点：</p><ul><li><p>系统文件管理，读取和修改</p></li><li><p>支持多格式文件查看</p></li><li><p>方便的查看应用目录</p></li><li><p>收藏路径，随时直达</p></li><li><p>文件压缩和解压</p></li><li><p>安装/查看ipa 程序</p></li><li><p>安装/查看deb 插件</p></li><li><p>文件导出和WiFi 传输</p></li></ul><h1 id="插件安装">插件安装</h1><p>Filza 免费即可下载，大家可以到官方源下载最新版本体验，目前已经适配iOS 11 系统。如果你是64位系统，请下载Filza File Manager 64-bit 版本。</p><p>名称：Filza File Manager</p><p>作者：TIGI Software</p><p>大小：21012kB</p><p>版本：3.5.2-4</p><p>价格：完整版$5.99</p><p>语言：英语</p><p>兼容：iOS 7~iOS 11</p><p>官方源：<a href="http://tigisoftware.com/cydia/" target="_blank" rel="noopener">http://tigisoftware.com/cydia/</a></p><p>首次安装Filza File Manager ，需要安装多个依赖。</p><p><img src="https://user-images.githubusercontent.com/16996753/53608689-c25b3500-3bfe-11e9-9821-42a01e2d0768.png" alt="image"></p><h1 id="功能介绍">功能介绍</h1><p>Filza 功能非常丰富，下面小编给大家简单介绍一下。</p><h2 id="文件查看和管理">文件查看和管理</h2><p>Filza 主打文件管理功能，可以读取手机内的所有文件，包含系统目录，Filza 支持多种格式的文件查看。<br><img src="https://user-images.githubusercontent.com/16996753/53608715-d69f3200-3bfe-11e9-9c3d-882474c2959e.png" alt="image"></p><p>你可以预览、查看、移动、修改、删除或者分享文件，给你电脑般的体验。解压和压缩文件也变得非常简单。<br><img src="https://user-images.githubusercontent.com/16996753/53608718-d99a2280-3bfe-11e9-8c08-dcea4b5bb5d7.png" alt="image"></p><p>移动文件，非常方便。编辑状态选择文件后，点击移动，会弹出提示。<br><img src="https://user-images.githubusercontent.com/16996753/53608724-ddc64000-3bfe-11e9-9b88-24781c4bd422.png" alt="image"></p><p>只需在你想移动到的文件夹点击一下粘贴按钮，文件就移动完成了。<br><img src="https://user-images.githubusercontent.com/16996753/53608728-e0289a00-3bfe-11e9-8983-a04478c7ba15.png" alt="image"></p><p>通过一些文件的修改或者替换，你可以实现很多内容，例如替换字体，替换提示铃声等等。</p><p>如下图所示为导入的铃声，可以预览或者删除。路径：</p><p>/private/var/mobile/Media/iTunes_Control/Ringtones<br><img src="https://user-images.githubusercontent.com/16996753/53608734-e4ed4e00-3bfe-11e9-8767-a0ec844c056e.png" alt="image"></p><p>搜索功能，可以帮你快速找到想要的文件，并定位到路径。点击搜索结果右上角的箭头，可以快速打开文件所在的位置。可以在根目录或者当前文件夹搜索。<br><img src="https://user-images.githubusercontent.com/16996753/53608740-e880d500-3bfe-11e9-90de-fbeb1a0dab7c.png" alt="image"></p><p>显示路径，当你打开一个文件夹，点击一下标题栏。<br><img src="https://user-images.githubusercontent.com/16996753/53608746-eb7bc580-3bfe-11e9-84d5-7dbc4260197f.png" alt="image"></p><p>就会当前文件夹显示路径，可以复制。</p><p>标签管理，点击底部的标签按钮，可以打开多页面，就像Safari 浏览器一样的多页面方式的管理，方便文件整理。<br><img src="https://user-images.githubusercontent.com/16996753/53608753-efa7e300-3bfe-11e9-9983-93155b5cf210.png" alt="image"></p><p>在多页面切换界面，底部按钮可以快速直达App 管理器，和音乐库管理器。</p><h1 id="善用收藏夹">善用收藏夹</h1><p>打开收藏夹，你可以快速到达特定的路径。点击右上角“+”号，你可以将当前的路径，添加到收藏夹，方便快速打开。</p><p>Filza 内置了一些收藏夹内容，例如App 管理器。<br><img src="https://user-images.githubusercontent.com/16996753/53608761-f8001e00-3bfe-11e9-8c94-ef257e8dad1c.png" alt="image"></p><p>App 管理器可以快速打开App 主目录，你可以打开每个App 的文件，查看详细内容，非常方便。<br><img src="https://user-images.githubusercontent.com/16996753/53608763-f9c9e180-3bfe-11e9-9a26-ff64c76e3296.png" alt="image"></p><p>Filza 内置回收站功能，你删除的文件可以在回收站内查看，以免误删文件。</p><h1 id="安装ipa-程序">安装IPA 程序</h1><p>Filza 内置ipa 安装和查看功能，使用Filza ，可以很方便的安装ipa 文件。</p><p>例如我们QQ中的ipa 文件，选择使用其他应用打开，拷贝到Filza。<br><img src="https://user-images.githubusercontent.com/16996753/53608766-ffbfc280-3bfe-11e9-99ed-b14dbd5e8305.png" alt="image"></p><p>在Filza 中打开ipa 文件，点击右上角的安装，即可快速安装。稍等片刻，返回桌面就会看到应用已经安装了。<br><img src="https://user-images.githubusercontent.com/16996753/53608768-03ebe000-3bff-11e9-9be1-eac0cc26c2d7.png" alt="image"></p><p>你也可以解压ipa 安装包，查看详细内容。例如查看info.plist 文件。<br><img src="https://user-images.githubusercontent.com/16996753/53608776-0817fd80-3bff-11e9-8ea0-09b3d2a3364e.png" alt="image"></p><p>在info.plist 文件可以轻松的找到应用的URL Schemes。</p><p><img src="https://user-images.githubusercontent.com/16996753/53608779-0bab8480-3bff-11e9-924f-7dce642915cb.png" alt="image"></p><h1 id="安装deb-文件">安装DEB 文件</h1><p>Filza 也支持deb 格式文件查看和安装，我们可以很方便的安装deb 插件。</p><p>例如一些没有上传到源的deb 包，例如在Cyida 无法打开的特殊情况，我们使用Filza 来安装修补插件，可以解决很多问题。</p><p>首先需要将deb 包拷贝到Filza ，然后点击打开，点击右上角的安装。</p><p><img src="https://user-images.githubusercontent.com/16996753/53608788-12d29280-3bff-11e9-8297-4b68e1c47699.png" alt="image"></p><p>你会看到安装进度和显示。安装完毕，如果插件是需要注销才能生效的类型，请点击右上角的注销，注销设备。</p><p><img src="https://user-images.githubusercontent.com/16996753/53608792-16661980-3bff-11e9-8745-dae8df20bfdb.png" alt="image"></p><p>打开Cydia ，在已安装→最近里面，可以看到刚刚安装的插件。值得注意的是，插件需要在Cydia 中才能卸载。</p><p><img src="https://user-images.githubusercontent.com/16996753/53608795-1a923700-3bff-11e9-834b-7331e31f3860.png" alt="image"></p><h1 id="文件导出和wifi-传输">文件导出和WiFi 传输</h1><p>Filza 拥有方便的文件导出功能，你可以将文件以邮件发送，或者使用其他App打开进行导出。</p><p><img src="https://user-images.githubusercontent.com/16996753/53608799-1e25be00-3bff-11e9-96a6-665c9339f1d1.png" alt="image"></p><p>Filza 支持Web 服务，进入设置，启动WebDAV 服务。</p><p><img src="https://user-images.githubusercontent.com/16996753/53608803-2120ae80-3bff-11e9-9cb9-e45c2632a19b.png" alt="image"></p><p>在同一网络的情况下，在电脑浏览器上输入地址，可以打开文件进行共享，实现在电脑上查看手机所有文件。<br><img src="https://user-images.githubusercontent.com/16996753/53608807-241b9f00-3bff-11e9-9c5f-1a4341cb7095.png" alt="image"></p><p>你可以直接下载 /重命名 / 删除文件。在没有数据线的情况下，导出文件也变得非常简单。</p><p><img src="https://user-images.githubusercontent.com/16996753/53608810-28e05300-3bff-11e9-91e7-f852ccde9a10.png" alt="image"></p><h1 id="丰富的设置">丰富的设置</h1><p>Filza 的设置非常丰富，你可以根据自身情况进行自定义。<br><img src="https://user-images.githubusercontent.com/16996753/53608815-2e3d9d80-3bff-11e9-96fe-c32c092fd980.png" alt="image"></p><p>例如文件显示，文件关联，或者文件查看器。<br><img src="https://user-images.githubusercontent.com/16996753/53608817-30076100-3bff-11e9-9a62-3eea81f34b99.png" alt="image"></p><p>你也可以对文件夹进行进行属性修改。在编辑状态选中文件夹，更多→属性，就可以修改了。</p><p><img src="https://user-images.githubusercontent.com/16996753/53608823-33025180-3bff-11e9-876c-d0ae55a13be8.png" alt="image"></p><h1 id="使用小结">使用小结</h1><p>iOS 系统没有文件管理器，也无法查看系统文件。越狱后，我们安装Filza File Manager，可以实现电脑版的文件管理功能。</p><p>Filza 可以说是非常强大：</p><ul><li><p>方便的文件管理系统</p></li><li><p>多格式文件查看或编辑</p></li><li><p>内置ipa /deb 安装器，可以轻松查看和安装ipa /deb 文件</p></li><li><p>便捷的文件移动/复制方式</p></li><li><p>支持搜索功能，快速找到想要的文件</p></li><li><p>App管理器，快速找到App 文件目录</p></li><li><p>支持Web 服务，方便的文件导入和导出</p></li></ul><p>有了Filza ，可以突破系统限制，轻松的完成很多事情。当然，对于系统文件，如果你不是那么熟悉，建议不要轻易删除或者修改，以免出错。</p><p>篇幅有限，文章仅仅介绍了Filza 的部分功能，更多使用技巧欢迎留言分享。</p><p>越狱后，有些插件是必须安装的，Filza 就是必备工具之一。</p><hr><p>Reference：</p><blockquote><p>GitHub Repo：<a href="https://github.com/CoderTonyChan/CoderTonyChan.github.io" target="_blank" rel="noopener">Tony Studio</a></p><p>Follow: <a href="https://github.com/CoderTonyChan" target="_blank" rel="noopener">CoderTonyCHan · GitHub</a></p></blockquote>]]></content:encoded>
      
      <comments>https://blog.tonystudio.ml/2018/08/08/ios-Filza/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Flex Summary</title>
      <link>https://blog.tonystudio.ml/2018/08/06/ios-flex/</link>
      <guid>https://blog.tonystudio.ml/2018/08/06/ios-flex/</guid>
      <pubDate>Sun, 05 Aug 2018 16:15:22 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;Flex 3 是iOS 系统的一款修改工具，需要越狱后安装。Flex 3 功能强大，使用简单，可以让用户修改iOS 系统功能，实现系统功能自定义；修改App 应用程序，或者去除广告，或者增强App 体验等，兼容iOS 11 系统。&lt;/p&gt;
&lt;/bl
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>Flex 3 是iOS 系统的一款修改工具，需要越狱后安装。Flex 3 功能强大，使用简单，可以让用户修改iOS 系统功能，实现系统功能自定义；修改App 应用程序，或者去除广告，或者增强App 体验等，兼容iOS 11 系统。</p></blockquote><hr><h1 id="flex-3介绍">Flex 3介绍</h1><p>Flex 3 主要特点：</p><ul><li>修改系统功能</li><li>修改应用程序</li><li>云端补丁库，免费下载使用</li></ul><h1 id="功能介绍">功能介绍</h1><hr><h2 id="脚本使用">脚本使用</h2><hr><p>Flex 3 通过添加补丁来工作。打开Flex 3 ，有三个分类：</p><p>我的补丁：存放所有已添加补丁</p><p>云端补丁：云端补丁库</p><p>仪表盘：插件信息，个人账户等<br><img src="https://user-images.githubusercontent.com/16996753/53608155-a787c100-3bfc-11e9-9ac0-885b90207d25.png" alt="image"></p><p>首页是我的补丁列表，这里存放的是你已经下载的所有补丁。可以自行选择开启或者关闭补丁，以颜色深浅区分。顶部点击编辑，可以对补丁进行排序。点击“+”号可以新建补丁。App 补丁会显示相应App 图标，需要该应用已经安装。系统补丁则显示默认手机图标。向左滑动，可以点击删除补丁。</p><p>点击底部云按钮，进入云端补丁，有四个分类：</p><p>Installed：本机已经安装的应用程序，点击即可查看相关补丁</p><p>Recent：最近上传到云端的补丁</p><p>Trending：流行的补丁</p><p>Popular：热门补丁</p><p>Search：搜索补丁</p><p><img src="https://user-images.githubusercontent.com/16996753/53608163-b2425600-3bfc-11e9-8cf0-c6990f3400b7.png" alt="image"></p><p>例如墨迹天气，点击即可查看App相关补丁，你可以查看补丁详细信息，也可以立即获取。</p><p><img src="https://user-images.githubusercontent.com/16996753/53608168-b66e7380-3bfc-11e9-9ca6-6d4fbe06f32d.png" alt="image"></p><p>补丁详细介绍页面标注了补丁的作者，描述（Description）补丁的用处，补丁适配App的版本，以及更新日期，补丁使用者的评论（comments），以及版本信息。如果补丁适合，点击GET即可下载。</p><p><img src="https://user-images.githubusercontent.com/16996753/53608179-bcfceb00-3bfc-11e9-93fc-c5fe9684a4a9.png" alt="image"></p><p>你下载的补丁会出现在“我的补丁”里面，打开开关，补丁就生效了。可以实现补丁介绍的效果，如图所示的墨迹天气优化补丁，当你打开应用你会发现顿时清爽了。你也可以查看或者编辑补丁。</p><p>App补丁无需注销，立即生效<br><img src="https://user-images.githubusercontent.com/16996753/53608186-c25a3580-3bfc-11e9-906c-d9e82a397a65.png" alt="image"></p><p>系统相关的补丁，当你打开或者关闭的时候，需要注销才能生效。</p><p><img src="https://user-images.githubusercontent.com/16996753/53608189-c5552600-3bfc-11e9-808d-66d691441cd8.png" alt="image"></p><p>系统补丁开启/关闭需要注销生效</p><p>你可以在云端寻找适合自己的补丁，搜索能快速寻找你需要的补丁。国内anton_j 、5iFlex、iBreak 等作者制作的补丁相当出色，介绍也非常详细。</p><p><img src="https://user-images.githubusercontent.com/16996753/53608194-c9814380-3bfc-11e9-94cb-bc7c8328caf8.png" alt="image"></p><p>在云端补丁的Installed分类，你可以找到SpringBoard（桌面）和System Wide （全系统）相关的补丁。</p><p><img src="https://user-images.githubusercontent.com/16996753/53608197-cc7c3400-3bfc-11e9-846d-ea5cbb1bc8f5.png" alt="image"></p><p>这里的补丁可以修改系统功能，如下图所示。值得注意的是，使用系统相关补丁前，请仔细查看补丁说明以及兼容性，看一下评论。一些不兼容的补丁，可能会引起问题。</p><p><img src="https://user-images.githubusercontent.com/16996753/53608201-cf772480-3bfc-11e9-9df1-d7f034dbae02.png" alt="image"></p><p>通过云端补丁库，即使你不会制作补丁，下载安装大神们已经制作好的补丁，也能享受Flex 3 的功能。</p><p>值得注意的是：</p><p>下载补丁前请自行阅读说明</p><p>App 补丁请仔细检查已安装版本是否匹配补丁要求，版本不一致会造成补丁无效</p><p>系统补丁请仔细核对是否兼容当前手机系统，以免出现问题</p><p>在仪表盘界面，你可查看Flex 3 的更新日志，登录账号，购买升级等等。</p><p><img src="https://user-images.githubusercontent.com/16996753/53608225-d736c900-3bfc-11e9-83d9-5a8d53734c87.png" alt="image"></p><p>已经下载的Flex 3补丁，会以patches.plist 合集的方式存在，你可以将补丁合集plist 文件导出备份，以免补丁丢失。</p><p>Flex 3 补丁路径</p><p>/var/mobile/Library/Application Support/Flex3</p><h1 id="配合app-admin-使用">配合App Admin 使用</h1><p>有了Flex 3，可以实现一些App 去除广告、获得额外功能。</p><p>但是有时候，已安装的App 版本和补丁要求不一致，我们可以使用App 降级插件，在App Store 降级应用，使用旧版，这样就能适合补丁使用。</p><p>名称：App Admin</p><p>作者：UnlimApps inc</p><p>大小：822kB</p><p>版本：目前1.0r-101</p><p>价格：免费</p><p>语言：英语</p><p>兼容：iOS 11</p><p>插件源：<a href="http://btea.unlimapps.com/" target="_blank" rel="noopener">http://btea.unlimapps.com/</a></p><p>App Admin 目前在测试中，兼容iOS 11 系统，主要作用：</p><p>App Store 安装任意版本软件</p><p>查看软件旧版本ID 号</p><p>App Admin 使用非常简单，安装后，打开App Store 即可使用。例如你已经下载过的软件，会显示云朵符号，点击云朵，弹出菜单。其中：</p><p>Continue：直接下载最新版本</p><p>Downgrade：降级软件版本<br><img src="https://user-images.githubusercontent.com/16996753/53608233-def66d80-3bfc-11e9-9c94-55a9ba3fed2f.png" alt="image"></p><p>我们选择Downgrade，就会弹出该软件的版本号列表，这里有尚在提供的所有旧版。</p><p>选择你需要安装的任意版本，点击即可下载。等待片刻，旧版软件就安装到手机了，非常简单轻松。<br><img src="https://user-images.githubusercontent.com/16996753/53608237-e1f15e00-3bfc-11e9-9ad3-664e8ff0e1a5.png" alt="image"></p><p>App Admin 支持屏蔽应用更新，长按更新按钮弹出菜单，选择“Block All Updates”，应用将不会出现在更新列表。在更新列表，点击左上角的齿轮标志，进入App Admin 设置界面。</p><p><img src="https://user-images.githubusercontent.com/16996753/53608263-f897b500-3bfc-11e9-90bc-cd205df73193.png" alt="image"></p><p>App Admin 设置界面可以管理屏蔽更新的应用，或者一些开关的控制。已经屏蔽更新的应用，可以在管理列表内删除。</p><p><img src="https://user-images.githubusercontent.com/16996753/53608268-fcc3d280-3bfc-11e9-8b81-31781daa1d9d.png" alt="image"></p><h1 id="一些补丁示例">一些补丁示例</h1><p>说了这么多，Flex 3 有什么强大之处呢？为什么要安装Flex 3 呢？下面介绍一些实用的补丁，或许是你安装Flex 3 的吸引力。</p><h2 id="去广告补丁">去广告补丁</h2><p>Flex 3 通过修改App实现去除App 广告，例如一些广告比较凶猛的观影工具，使用Flex 3 可以轻松解决，给你一个清爽的体验。<br><img src="https://user-images.githubusercontent.com/16996753/53608292-19f8a100-3bfd-11e9-91c7-b25e3e8bd43a.png" alt="image"></p><p>使用小结</p><p>Flex 3 是一款功能强大的iOS 修改器，通过自行修改变量、参数及函数等等，可以实现很多功能，例如去除广告，增强App体验，带来更多功能等。如果你会编写补丁，可以自行修改。即使你不会编写，你也可以从云端下载补丁，享受Flex 3 带来的乐趣。</p><p>有时候，无需安装插件，一个小小的补丁就可以搞定，方便简单。</p><p>注意事项：</p><p>下载补丁前请仔细阅读说明，观看使用评论</p><p>一些历史悠久的补丁一般都会失效</p><p>Installed 列表并不保证显示所有已经安装的应用，部分应用会无显示</p><p>使用App 补丁前请仔细检查已安装版本是否匹配补丁要求，版本不一致会造成补丁无效</p><p>系统补丁请仔细核对是否兼容当前手机系统，以免出现问题</p><p>在云端补丁库，部分应用或许没有任何补丁</p><p>云端补丁可能会因为部分原因下架，例如一些破解补丁，如果遇到好的补丁，请及时下载</p><p>篇幅有限，文章仅仅简单的介绍了Flex 3的部分功能，希望对新手朋友有帮助吧，更多使用技巧欢迎留言分享。</p><p>越狱后，有些插件是必须安装的，Flex 3  会是您的必备工具之一吗？</p><hr><p>Reference：</p><blockquote><p>GitHub Repo：<a href="https://github.com/CoderTonyChan/CoderTonyChan.github.io" target="_blank" rel="noopener">Tony Studio</a></p><p>Follow: <a href="https://github.com/CoderTonyChan" target="_blank" rel="noopener">CoderTonyCHan · GitHub</a></p></blockquote>]]></content:encoded>
      
      <comments>https://blog.tonystudio.ml/2018/08/06/ios-flex/#disqus_thread</comments>
    </item>
    
    <item>
      <title>WWDC 2018</title>
      <link>https://blog.tonystudio.ml/2018/06/05/WWDC-2018/</link>
      <guid>https://blog.tonystudio.ml/2018/06/05/WWDC-2018/</guid>
      <pubDate>Mon, 04 Jun 2018 16:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;一年一度的 WWDC（苹果全球开发者大会）于北京时间 6月5日 凌晨1点开幕。废话不多说，来看看这次WWDC 都有哪些亮点吧!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;ios-12-和-arkit-20&quot;&gt;iOS 12 和 ARKit 
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>一年一度的 WWDC（苹果全球开发者大会）于北京时间 6月5日 凌晨1点开幕。废话不多说，来看看这次WWDC 都有哪些亮点吧!</p></blockquote><h2 id="ios-12-和-arkit-20">iOS 12 和 ARKit 2.0</h2><blockquote><p>关键词：官方防沉迷最为致命</p></blockquote><h3 id="ios-12">iOS 12</h3><p>iOS 12 相较于 iOS 11 并没有太多UI上的变动，刚更新完 bate 版本的 iOS 12，完全感觉不到这是个新系统。</p><p>iOS 12 主要是对安全和性能的优化，iOS 12 在旧设备上的运行速度比 iOS 11更块，程序加载速度快了一倍。（PS：看来苹果并没有放弃旧设备）</p><p><img src="https://cdn.mos.cms.futurecdn.net/RdxhPVv8fAyM6oHsRgF6dH-650-80.png" alt=""></p><h3 id="arkit-20">ARKit 2.0</h3><p>Apple 与 皮克斯 合作开发了一种用于共享AR内容的新文件格式，新的 AR 格式名为 USDZ。</p><p>作为一个含着金苹果出生的新生儿，USDZ 一开始就得到了 Adobe Creative Cloud （包括 Photoshop CC、InDesign CC、Illustrator CC、Dreamweaver CC、Premiere Pro CC）套件的支持。</p><p><img src="https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-10.jpg" alt=""></p><p>同时，面向开发者的开发套件 ARKit 则升级到了二代，主要提升了面部跟踪、渲染能力、3D 探测和共享体验等能力。</p><p>随后展示了一款名为 Measure 的 App，可使用AR查看物品大小。</p><p><img src="https://cdn.mos.cms.futurecdn.net/4tbGCxGUGsH9VwSLsfMDK5-650-80.png" alt=""></p><p>最后为了演示新的 AR 能力和效果，苹果请来了乐高的创意总监来捧场。这是一个真实的乐高积木建筑物为基础，最多四个人可以用苹果 AR 应用进行游戏，可以在真实环境中模拟出各种虚拟的形象和建筑。</p><p><img src="https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-9.jpg" alt=""><br><img src="https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-11.jpg" alt=""></p><h3 id="相册优化">相册优化</h3><p>iOS 12 的相册将大大提升搜索性能，系统不仅会提出搜索建议，还会帮你按主题整理照片。</p><p><img src="https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-13.jpg" alt=""></p><p><img src="https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-14.jpg" alt=""></p><h3 id="siri变得更聪明">Siri变得更聪明</h3><p>iOS 12 中，苹果为 Siri 提供了更加高效的操作，让它可以操作各个应用内部的功能，并且能在锁屏界面建议用户下一步的行动。</p><p>苹果还发布了一款名为「Shortcuts」的应用，它允许用户自定义 Siri 搜索指令，支持通过拖拽来快速编辑指令，同时还提供了一个指令库供用户下载现成的命令，就像是为 Siri 打造的 Workflow 自动化工具。</p><p><img src="https://cdn.sspai.com/2018-06-04-Artboard.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt=""></p><p>看到这里，相比熟悉苹果的朋友大概明白了，Siri 的本次改进，很可能是源于它收购的效率神器 Workflow，堪称一个用 Siri 唤醒的 Workflow。</p><h3 id="原生应用大更新">原生应用大更新</h3><p>iOS 12 中，不少原生应用都得到了更新。</p><ul><li>iBooks 更名为 <strong>Apple Books</strong>，采用类似 App Store 的新界面设计。</li><li>新闻应用（News）在 iPad 上新添加了侧边栏，方便浏览，也突出策划内容。</li><li>语音备忘录现在支持 iCloud 了</li><li>股市的界面重构，可以看到股票全天走势，并打通 News 应用，方便看财经新闻；</li></ul><h3 id="carplay-开放了">CarPlay 开放了</h3><p><img src="https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-21.jpg" alt=""></p><p>CarPlay 变得更加开放了，曾经被苹果狠心抛弃的 Google Maps 和 Google 的干儿子地图 Waze，以及来自东方的神秘力量高德地图成为首批 CarPlay 支持的第三方导航，从此“志玲姐姐为您导航”将可以常伴林肯领航者车主左右，中国梦和美国梦一起实现。</p><h3 id="防手机沉迷-划重点">防手机沉迷 - 划重点！</h3><p>本次 iOS 12 的重点就是：<strong>防沉迷！</strong></p><p><img src="https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-25.jpg" alt=""></p><p>鉴于手机上瘾成为了一个社会议题，今年 Google 和苹果都不约而同地将“防沉迷”加入到了系统更新当中：</p><ul><li>**Do Not Disturb（别吵我）**功能将关掉手机的视觉通知，在夜深人静想起她或梦见她的时候，来了邮件也不会亮屏刺破夜的静谧和黑暗</li><li>Deliver Quietly（安静通知）则是将消息推送静默化、不显示在锁屏，也不出声，也不会在 app 右上角标红</li><li><strong>Grouped Notifications（分组通知</strong>）可以将某一类型的通知归组，微信群聊消息不再有轰炸的感觉</li><li>**Reports（应用报告）**可以用周报告的形式，告诉用户用什么应用最多，哪个应用通知最多，每天起床第一个打开的是什么应用等等</li><li><strong>App Limits（应用限制</strong>）可以给某个应用规定使用时间，当然这不是强制性的，用户可以突破限制继续“吃鸡”</li><li><strong>Allowances（零用钱？）</strong> 是家长限制孩子使用应用的新特性</li></ul><h3 id="imessage-和-feactime">iMessage 和 FeacTime</h3><p>Animoji 新增了 4 个新表情（幽灵，考拉，老虎和霸王龙），用户还可以为自己量身定做 Animoji ，并用到各种场景——这就是全新的 Memoji 技术</p><p><img src="https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-26.jpg" alt=""></p><p><img src="https://cdn.sspai.com/2018/06/05/67b6fba3d36bdd7caf09bec94dcb157b.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt=""></p><p>iOS 版 <strong>FaceTime</strong> 迎来了群聊功能，最多支持 32 人同时聊天，成员可以随时加入或离开聊天。聊天界面用瀑布流的形式呈现，正在说话的成员窗口会自动放大。macOS 版 FaceTime 同样也得到了更新。</p><p><img src="https://cdn.sspai.com/2018-06-04-Screen%20Shot%202018-06-05%20at%202.00.58%20AM.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt=""></p><h2 id="tvos">tvOS</h2><blockquote><p>关键词：优化试听体验</p></blockquote><p>tvOS 今年的变化比较小，更新主要集中在了影视资源以及细节优化上。</p><p>Apple TV 4K 将支持杜比全景声和杜比视界，让你在家里也能获得电影院般的听觉体验。</p><p><img src="https://cdn.sspai.com/2018-06-04-Screen%20Shot%202018-06-05%20at%202.26.21%20AM.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt=""></p><h2 id="watchos-5">watchOS 5</h2><blockquote><p>关键词：运动进行到底</p></blockquote><p>随着 Apple Watch 成长的，还有它的操作系统 watchOS，这一次 watchOS 升级到了第五代。</p><p><img src="https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-31.jpg" alt=""></p><p>Apple Watch 的功能朝着运动的方向发展，此次 watchOS 5 的更新，也以运动为主。</p><p><img src="https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-35.jpg" alt=""></p><p>watchOS 5 的一个小惊喜是让 Apple Watch 成为了对讲机，这个应用名为 Walkie Talkie（对讲机）。</p><p><img src="https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-38.jpg" alt=""></p><p>Apple Watch 早就支持了 Apple Pay，不过在通知上，Apple Watch 显然可以做得更多，比如值机和给滴滴师傅付款评分，手表不再只是个通知器，也能做些轻交互。</p><p><img src="https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-51.jpg" alt=""></p><p>还有 Apple Watch 可以浏览网页了~</p><h2 id="macos-mojave">macOS Mojave</h2><blockquote><p>关键词：夜间模式、全新的App Store</p></blockquote><p><img src="https://cdn.sspai.com/2018-06-04-macOS01.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt=""></p><p>对于大多数人来说，macOS 更新最大的悬念，是新系统叫什么名字。</p><p>答案是：<strong>macOS Mojave</strong>，Mojave 中译名是莫哈韦沙漠，位于在美国加利福尼亚西南，出于洛杉矶和拉斯维加斯之间。</p><p>在 Mojave 这版系统中，苹果加入了一套适应暗光环境下使用的夜间主题，并对 Mac App Store 的交互界面进行了重塑，整个系统的改变甚至连库克都称为是苹果的一次 “巨大的跨越”。</p><p><img src="https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-89.jpg" alt=""></p><h3 id="夜间模式-动态桌面">夜间模式 / 动态桌面</h3><p>不少用户会在暗光环境下使用电脑，即便是将屏幕亮度调到最低，也难免会因为白底色为主的主题而感到刺眼。在这次更新中，macOS Mojave 新增加了一套暗色主题，不同于目前将菜单和程序栏调成暗色的选项，新系统上的是一套全局暗色主题，即便是在文件夹、应用里都是以黑色为主色呈现。</p><p><img src="https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-63.jpg" alt=""></p><p>另外，系统可根据时间变化对桌面进行自动调整，日间使用时系统为正常主题；夜间使用时系统则自动切换至暗色模式主题。此时，台下的开发者们爆发出了一阵欢呼，大概是这个主题能够提升程序员朋友夜间加班的幸福感吧。</p><p><img src="https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-63.jpg" alt=""></p><h3 id="智能分类">智能分类</h3><p>macOS 会跟据文件类型和标签对桌面的文件进行自动分类整理，从此再也不用担心满桌面都是文件了。</p><p><img src="https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-82.jpg" alt=""></p><p><img src="https://cdn.sspai.com/2018-06-04-macOS04.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt=""></p><h3 id="快速查看升级">快速查看升级</h3><p><img src="https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-92.jpg" alt=""></p><p>访达在这次系统上的更新并不多，只是针对图片查看增添了 “图库视图” 功能。通过 “图库视图”，用户可更加便捷快速地浏览到访达文件夹内的图片内容，与此同时功能内部也内置了图片元数据显示窗，用户可以借助数据窗口了解到图片的相关详情，并且可对图片进行快速编辑操作。</p><h3 id="截图录屏操作-类似ios">截图/录屏操作 - 类似iOS</h3><p><img src="https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-93.jpg" alt=""></p><p>此次 macOS Mojave 加入了 “系统级” 的截屏功能，用户也可以在截屏后对截屏图片进行简单的标记。不过实际上，目前不少社交软件其实都已经具备了截图 + 标记的相关功能，且在体验上也相当不错。</p><h3 id="安全权限">安全权限</h3><p>当我们在 iOS 系统上打开刚下载的应用程序时，系统会弹出弹窗，提示是否允许程序访问用户信息和手机硬件。而这次苹果也将相关的安全控制策略从 iOS “搬” 到了 macOS 上，当用户打开某个网址或程序时，系统会弹出 “是否允许访问” 的弹窗以获得用户批准。这也可能是为了呼应最近越发严格的隐私政策。</p><h3 id="在-macos-上运行的几款-ios-程序">在 macOS 上运行的几款 iOS 程序</h3><p><img src="https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-84.jpg" alt=""></p><p>将 iOS 的应用程序搬到 macOS 上运行是不少玩家曾经有过的想法。此次苹果在新版的 macOS 系统上加入了 iOS 端的新闻、股市、家、语音备忘录四个程序，用户可以在桌面系统上通过这几款应用阅读新闻、控制家庭设备等等。</p><p>在发布会的最后，苹果否认了将对 iOS 和 macOS 进行合并的传闻，但考虑到 iOS 平台有非常庞大的应用数量，他们也希望其中的部分应用能来到 macOS。于是苹果在发布会上为大家提前预览了一个准备多年的项目，macOS 将可以使用 iOS 的 UIKit 框架进行开发，以降低开发多平台应用的成本。</p><p><img src="https://cdn.sspai.com/2018-06-04-Screen%20Shot%202018-06-05%20at%203.08.05%20AM.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt=""></p><p>比如这次 macOS Mojave 中新增的 4 款应用——News、股票、语音备忘录、家庭——均采用了这种新技术。</p><h3 id="全新的-mac-app-store">全新的 Mac App Store</h3><p><img src="https://cdn.sspai.com/2018-06-04-macOS09.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt=""></p><p>在 iOS 11 对 Mac App Store 进行了重新设计后，macOS Mojave 也迎来了全新设计的 Mac App Store。新版拥有与 iOS 上 App Store 类似的发现页，里面能看到每日编辑推荐和一些 App 的使用技巧。进入 App 页面后，你可以看到视频预览和与 iOS 类似的评分系统。为了方便用户评分，新版 macOS 还加入了和 iOS 一样的 App 内打分功能。此外，苹果还宣布包括 Office 365 和 Adobe Lightroom CC 在内的一批重量级 App 将在今年稍后登录 Mac App Store。</p><h2 id="结语">结语</h2><p>是的，这次的 WWDC 只有软件，没有新的电子设备发布，没有新 iPad Pro、没有 iPhone SE2、没有带八代酷睿的新 MacBook，唯一能和“硬件”沾上边的就是一个新的彩虹表带。</p><p><img src="https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-56.jpg" alt=""></p><p>时至今日，苹果生态已经日趋完善了，大概苹果的产品经理们也想不出什么石破天惊的功能让大家 wow 一声了，有的只是细节层面的改进。作为看客和用户，也只能接受这样的现实了。</p><p>对了，那个可以四个人一起玩的乐高积木和 AR 应用，倒是可以考虑买来玩一下，不要一边说没有新东西，一边又对新东西视而不见。</p><p>对于 iOS 开发者来说，macOS 将可以使用 iOS 的 UIKit 框架进行开发是一个值得关注的点。</p><h3 id="参考">参考</h3><ul><li><a href="https://developer.apple.com/videos/play/wwdc2018/101/" target="_blank" rel="noopener">WWDC 2018 Keynote</a></li><li><a href="https://www.techradar.com/news/apple-wwdc-2018-keynote" target="_blank" rel="noopener">Apple WWDC 2018: what’s new? All the announcements from the keynote</a></li><li><a href="http://www.ifanr.com/1043270" target="_blank" rel="noopener">iOS 加入「防沉迷」，macOS 有了暗色主题，今年的 WWDC 重点都在系统上</a></li><li><a href="https://sspai.com/post/44816" target="_blank" rel="noopener">苹果 WWDC 2018：最全总结看这里，不错过任何重点</a></li></ul><hr><p>Reference：</p><blockquote><p>GitHub Repo：<a href="https://github.com/CoderTonyChan/CoderTonyChan.github.io" target="_blank" rel="noopener">Tony Studio</a></p><p>Follow: <a href="https://github.com/CoderTonyChan" target="_blank" rel="noopener">CoderTonyCHan · GitHub</a></p></blockquote>]]></content:encoded>
      
      <comments>https://blog.tonystudio.ml/2018/06/05/WWDC-2018/#disqus_thread</comments>
    </item>
    
    <item>
      <title>HTTP/HTTPS 抓包 ---- Thor</title>
      <link>https://blog.tonystudio.ml/2018/05/30/HTTPS-Thor/</link>
      <guid>https://blog.tonystudio.ml/2018/05/30/HTTPS-Thor/</guid>
      <pubDate>Wed, 30 May 2018 02:51:24 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;Thor 是一款 iOS 上强大的抓包能手，主要用来在 iOS 上进行网络抓包，是一款开发调试利器，并无隐藏功能，并无隐藏功能，纯、专业、抓包、工具。&lt;br&gt;
下面我们来了解它们的用法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;抓包&quot;&gt;
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>Thor 是一款 iOS 上强大的抓包能手，主要用来在 iOS 上进行网络抓包，是一款开发调试利器，并无隐藏功能，并无隐藏功能，纯、专业、抓包、工具。<br>下面我们来了解它们的用法。</p></blockquote><h1 id="抓包">抓包</h1><hr><p>先打开Thor工具→点击蓝色按钮→按钮变为橘红色开始抓包</p><p><img src="https://user-images.githubusercontent.com/16996753/53926766-b1f40000-40bf-11e9-911d-56ddfb620f33.png" alt="image"></p><p>回到某音软件→播放目标视频播放过后→回到Thor工具→点击橘红按钮停止抓包→打开抓包记录后可看到本次抓包的记录</p><p><img src="https://user-images.githubusercontent.com/16996753/53926801-cafcb100-40bf-11e9-866e-0894435d1676.png" alt="image"></p><p>打开这条记录，可以看到这次抓包的全部数据</p><p><img src="https://user-images.githubusercontent.com/16996753/53926806-cf28ce80-40bf-11e9-9990-d93fc17d645e.png" alt="image"></p><h1 id="过滤器">过滤器</h1><hr><p>例如这次我们抓取某音的视频数据中，找出那些目标数据共同的地方</p><p><img src="https://user-images.githubusercontent.com/16996753/53926892-0ac39880-40c0-11e9-97d4-6ef7d9bc2637.png" alt="image"></p><p>回到软件主页面→点击上方的过滤器选择选项→点击“+”→再点击“添加过滤器”</p><p><img src="https://user-images.githubusercontent.com/16996753/53926912-1a42e180-40c0-11e9-8c94-6a6f55e11063.png" alt="image"></p><p>指定“匹配HTTP方法”→选择需要匹配HTTP的方法（可多选）</p><p><img src="https://user-images.githubusercontent.com/16996753/53926928-26c73a00-40c0-11e9-970f-1633bae5c542.png" alt="image"></p><p>指定“包括关键字”→点击“+”添加关键字</p><p><img src="https://user-images.githubusercontent.com/16996753/53926951-43fc0880-40c0-11e9-96fb-985a46acd774.png" alt="image"></p><h1 id="如何分享自己的过滤器">如何分享自己的过滤器</h1><p>这里以QQ为例别人通过QQ分享给你→点击下载→点击“用其他应用打开”→找到“拷贝到Thor”图标点击</p><p><img src="https://user-images.githubusercontent.com/16996753/53926994-655cf480-40c0-11e9-970f-0da09f4ba1f3.png" alt="image"></p><p>进入过滤器预览界面→点击右上角图标→弹出选框点“安装”</p><p><img src="https://user-images.githubusercontent.com/16996753/53927007-6c840280-40c0-11e9-97d7-5ebe2fef2e11.png" alt="image"></p><hr><p>Reference：</p><blockquote><p>GitHub Repo：<a href="https://github.com/CoderTonyChan/CoderTonyChan.github.io" target="_blank" rel="noopener">Tony Studio</a></p><p>Follow: <a href="https://github.com/CoderTonyChan" target="_blank" rel="noopener">CoderTonyCHan · GitHub</a></p></blockquote>]]></content:encoded>
      
      <comments>https://blog.tonystudio.ml/2018/05/30/HTTPS-Thor/#disqus_thread</comments>
    </item>
    
    <item>
      <title>MacOS/Linux下的串口通信</title>
      <link>https://blog.tonystudio.ml/2018/05/21/MacOS-Linux-Com/</link>
      <guid>https://blog.tonystudio.ml/2018/05/21/MacOS-Linux-Com/</guid>
      <pubDate>Mon, 21 May 2018 02:51:24 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;在windows下实现串口通信一般采用串口助手之类的东西来发送和接收信息，而LINUX也有相应的串口助手之类的东西，如xgcom,完全的图形化界面，可以在github下载源码，编译安装。当然LINUX下自然minicom之类的终端，但是使用起来也并不顺手（而且不支持16进制
        
      
      </description>
      
      <content:encoded><![CDATA[<p>在windows下实现串口通信一般采用串口助手之类的东西来发送和接收信息，而LINUX也有相应的串口助手之类的东西，如xgcom,完全的图形化界面，可以在github下载源码，编译安装。当然LINUX下自然minicom之类的终端，但是使用起来也并不顺手（而且不支持16进制的发送和显示）。下面就说说如何不利用额外的工具，直接使用SHELL实现串口的通信。</p><hr><h1 id="检测串口">检测串口</h1><hr><p>在LINUX下首先需要检测串行口驱动是否正常，而串行口设备一般为/dev/ttyS*,如果是USB转串行口的，则为/dev/ttyUSB*，这点只需要在/dev下查看一下即口。</p><p>假设现在连接收的设备的为/dev/ttyUBS0，则可以使用命令来查看串口情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dmesg |grep -i ttyUSB0</span><br><span class="line">[68364.967637] usb 3-4: pl2303 converter now attached to ttyUSB0</span><br></pre></td></tr></table></figure><h1 id="设置串口设备">设置串口设备</h1><hr><p>shell的串口设置工具使用stty,是一个用于设置终端行为的工具。stty是linux的核心工具之一，基本LINUX都会有。</p><p>串口有主的设置有下面几个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">波特率(e.g. 9600)</span><br><span class="line">数据位(e.g. 8)</span><br><span class="line">停止位(e.g. 1)</span><br><span class="line">效检位(e.g. 无效检位)</span><br></pre></td></tr></table></figure><p>下面使用stty来完成该串口的设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo stty -F /dev/ttyUSB0 raw speed 9600 cs8 -parenb -cstopb cread clocal</span><br></pre></td></tr></table></figure><p>为什么是这个样呢？下面逐个来解释一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-F /dev/ttyUSB0     使用-F可以指定设备名</span><br><span class="line">raw                 这是一组设置的组合体,详情可man stty</span><br><span class="line">speed 9600          指定波特率</span><br><span class="line">cs8                 指定数据位</span><br><span class="line">-parenb             无奇偶效检</span><br><span class="line">-cstopb             1停止位(如果为2位，则为cstopb)</span><br><span class="line">cread               允许输入能够接收</span><br><span class="line">clocal              禁止调制解调器的控制信号(不明)</span><br></pre></td></tr></table></figure><h1 id="串口输入与输出">串口输入与输出</h1><hr><p>串口的输入输的输自然是比较简单，只需要将/dev/ttyUSB0当作文件一样，使用重定向或者cat来输入或输出即可。</p><p>对于输出自然不用说了，只需要简单的cat即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cat /dev/ttyUSB0</span><br></pre></td></tr></table></figure><p>如果没有数据，那么cat就会停在这个地方不动了，如果有数据，那么cat就会源源不断的将内容显示出来。下面主要说说如何输入。</p><p>最简单的的输入方法自然是使用echo命令。echo命令是足够强大的，能够输出各种格式的内容。其中最常见的是输入出文本数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo echo 123 &gt; /dev/ttyUSB0</span><br></pre></td></tr></table></figure><p>那么如果我需要输入二进制/八进制/十六进制的数据怎么办？echo自然可以使用-e选项来转换。例如，如果向ttyUSB0中输入一个十六进制的数据”80 8F”，则命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo echo  -en &quot;\x80\x8F&quot; &gt; /dev/ttyUSB0</span><br></pre></td></tr></table></figure><p>默认的echo会在后面加上换行符，所以需要-n选项去掉默认加上的换行符，关于这一点可以使用xxd来查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -e “\x80\8F” | xxd</span><br></pre></td></tr></table></figure><h1 id="例子测试">例子测试</h1><hr><p>手上有一个Android系统公司的产品, 通过Termux安装了一个ubuntu 32bit. 下面记录他的串口通信. 如何SSH进去不在讨论范围.</p><h2 id="设置">设置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stty -F /dev/ttyS1 raw speed 921600</span><br></pre></td></tr></table></figure><h2 id="显示">显示</h2><p>cat 默认是utf8 编码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /dev/ttyS1</span><br></pre></td></tr></table></figure><p>显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">?</span><br><span class="line">?I?</span><br><span class="line">?I?</span><br><span class="line">?I?</span><br><span class="line">?I?</span><br><span class="line">?I?</span><br><span class="line">?I?</span><br><span class="line">?I?</span><br><span class="line">?I?</span><br><span class="line">?I?</span><br></pre></td></tr></table></figure><p>16进制显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat /dev/ttyS1|hexdump -C</span><br><span class="line">cat /dev/ttyS1|hexdump</span><br><span class="line">cat /dev/ttyS1|xxd</span><br><span class="line">cat /dev/ttyS1|od -x</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@new55 ~]# echo /etc/passwd | hexdump</span><br><span class="line">0000000 652f 6374 702f 7361 7773 0a64         </span><br><span class="line">000000c</span><br><span class="line">[root@new55 ~]# echo /etc/passwd | od -x</span><br><span class="line">0000000 652f 6374 702f 7361 7773 0a64</span><br><span class="line">0000014</span><br><span class="line">[root@new55 ~]# echo /etc/passwd | xxd</span><br><span class="line">0000000: 2f65 7463 2f70 6173 7377 640a            /etc/passwd.</span><br><span class="line">[root@new55 ~]# echo /etc/passwd | hexdump -C      &lt;== 规范的十六进制和ASCII码显示（Canonical hex+ASCII display ）</span><br><span class="line">00000000  2f 65 74 63 2f 70 61 73  73 77 64 0a              |/etc/passwd.|</span><br><span class="line">0000000c</span><br></pre></td></tr></table></figure><h2 id="输入输出">输入输出</h2><p>根据公司的串口通信协议 可以正常开灯</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo  -en &quot;\xAA\x00\x0F\x04\x00\x10\x03\x00\x03\x04\x00\x04\x02\x3A\xCD&quot; &gt; /dev/ttyS1</span><br></pre></td></tr></table></figure><hr><p>Reference：</p><blockquote><p>GitHub Repo：<a href="https://github.com/CoderTonyChan/CoderTonyChan.github.io" target="_blank" rel="noopener">Tony Studio</a></p><p>Follow: <a href="https://github.com/CoderTonyChan" target="_blank" rel="noopener">CoderTonyCHan · GitHub</a></p></blockquote>]]></content:encoded>
      
      <comments>https://blog.tonystudio.ml/2018/05/21/MacOS-Linux-Com/#disqus_thread</comments>
    </item>
    
    <item>
      <title>HTTP/HTTPS 抓包 ---- mitmproxy</title>
      <link>https://blog.tonystudio.ml/2018/04/30/HTTPS-mitmproxy/</link>
      <guid>https://blog.tonystudio.ml/2018/04/30/HTTPS-mitmproxy/</guid>
      <pubDate>Mon, 30 Apr 2018 02:51:24 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;mitmproxy是一个支持HTTP和HTTPS的抓包程序，有类似Fiddler、Charles的功能，只不过它是一个控制台的形式操作。&lt;br&gt;
mitmproxy还有两个关联组件。一个是mitmdump，它是mitmproxy的命令行接口，利用它
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>mitmproxy是一个支持HTTP和HTTPS的抓包程序，有类似Fiddler、Charles的功能，只不过它是一个控制台的形式操作。<br>mitmproxy还有两个关联组件。一个是mitmdump，它是mitmproxy的命令行接口，利用它我们可以对接Python脚本，用Python实现监听后的处理。另一个是mitmweb，它是一个Web程序，通过它我们可以清楚观察mitmproxy捕获的请求。<br>下面我们来了解它们的用法。</p></blockquote><h1 id="一-准备工作">一、准备工作</h1><hr><p>请确保已经正确安装好了mitmproxy，并且手机和PC处于同一个局域网下，同时配置好了mitmproxy的CA证书。</p><h1 id="二-mitmproxy的功能">二、mitmproxy的功能</h1><hr><p>mitmproxy有如下几项功能。</p><ul><li><p>拦截HTTP和HTTPS请求和响应。</p></li><li><p>保存HTTP会话并进行分析。</p></li><li><p>模拟客户端发起请求，模拟服务端返回响应。</p></li><li><p>利用反向代理将流量转发给指定的服务器。</p></li><li><p>支持Mac和Linux上的透明代理。</p></li><li><p>利用Python对HTTP请求和响应进行实时处理。</p></li></ul><h1 id="三-抓包原理">三、抓包原理</h1><hr><p>和Charles一样，mitmproxy运行于自己的PC上，mitmproxy会在PC的8080端口运行，然后开启一个代理服务，这个服务实际上是一个HTTP/HTTPS的代理。</p><p>手机和PC在同一个局域网内，设置代理为mitmproxy的代理地址，这样手机在访问互联网的时候流量数据包就会流经mitmproxy，mitmproxy再去转发这些数据包到真实的服务器，服务器返回数据包时再由mitmproxy转发回手机，这样mitmproxy就相当于起了中间人的作用，抓取到所有Request和Response，另外这个过程还可以对接mitmdump，抓取到的Request和Response的具体内容都可以直接用Python来处理，比如得到Response之后我们可以直接进行解析，然后存入数据库，这样就完成了数据的解析和存储过程。</p><h1 id="四-设置代理">四、设置代理</h1><hr><p>首先，我们需要运行mitmproxy，命令如下所示：</p><p>启动mitmproxy的命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mitmproxy</span><br></pre></td></tr></table></figure><p>之后会在8080端口上运行一个代理服务，如下图所示。<br><img src="https://user-images.githubusercontent.com/16996753/53460122-fe638e00-3a76-11e9-8be2-12f9f7a85194.png" alt="image"><br>右下角会出现当前正在监听的端口。</p><p>或者启动mitmdump，它也会监听8080端口，命令如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mitmdump</span><br></pre></td></tr></table></figure><p>运行结果如下图所示。<br><img src="https://user-images.githubusercontent.com/16996753/53460127-015e7e80-3a77-11e9-8897-196e4a7c1367.png" alt="image"></p><p>将手机和PC连接在同一局域网下，设置代理为当前代理。首先看看PC的当前局域网IP。</p><p>Windows上的命令如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig</span><br></pre></td></tr></table></figure><p>Linux和Mac上的命令如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><p>输出结果如下图所示。<br><img src="https://user-images.githubusercontent.com/16996753/53460161-1b985c80-3a77-11e9-9546-bf0cfae6bca5.png" alt="image"></p><p>一般类似10.<em>.</em>.<em>或172.16.</em>.*或192.168.1.*这样的IP就是当前PC的局域网IP，例如此图中PC的IP为192.168.1.28，手机代理设置类似如下图所示。</p><p><img src="https://user-images.githubusercontent.com/16996753/53460171-29e67880-3a77-11e9-9f8c-d5b3eeb48d5c.png" alt="image"></p><p>这样我们就配置好了mitmproxy的的代理。</p><h1 id="五-mitmproxy的使用">五、mitmproxy的使用</h1><hr><p>确保mitmproxy正常运行，并且手机和PC处于同一个局域网内，设置了mitmproxy的代理，具体的配置方法可以参考官方文档。</p><p>运行mitmproxy，命令如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mitmproxy</span><br></pre></td></tr></table></figure><p>设置成功之后，我们只需要在手机浏览器上访问任意的网页或浏览任意的App即可。例如在手机上打开百度，mitmproxy页面便会呈现出手机上的所有请求，如下图所示。<br><img src="https://user-images.githubusercontent.com/16996753/53460202-4a163780-3a77-11e9-95d8-b9e42106c4dd.png" alt="image"></p><p>这就相当于之前我们在浏览器开发者工具监听到的浏览器请求，在这里我们借助于mitmproxy完成。Charles完全也可以做到。</p><p>这里是刚才手机打开百度页面时的所有请求列表，左下角显示的2/38代表一共发生了38个请求，当前箭头所指的是第二个请求。</p><p>每个请求开头都有一个GET或POST，这是各个请求的请求方式。紧接的是请求的URL。第二行开头的数字就是请求对应的响应状态码，后面是响应内容的类型，如text/html代表网页文档、image/gif代表图片。再往后是响应体的大小和响应的时间。</p><p>当前呈现了所有请求和响应的概览，我们可以通过这个页面观察到所有的请求。</p><p>如果想查看某个请求的详情，我们可以敲击回车，进入请求的详情页面，如下图所示。</p><p><img src="https://user-images.githubusercontent.com/16996753/53460218-5601f980-3a77-11e9-9414-88feaead5db0.png" alt="image"></p><p>可以看到Headers的详细信息，如Host、Cookies、User-Agent等。</p><p>最上方是一个Request、Response、Detail的列表，当前处在Request这个选项上。这时我们再点击TAB键，即可查看这个请求对应的响应详情，如下图所示。</p><p><img src="https://user-images.githubusercontent.com/16996753/53460232-60bc8e80-3a77-11e9-8c2f-7c1f2c08b0ed.png" alt="image"></p><p>最上面是响应头的信息，下拉之后我们可以看到响应体的信息。针对当前请求，响应体就是网页的源代码。</p><p>这时再敲击TAB键，切换到最后一个选项卡Detail，即可看到当前请求的详细信息，如服务器的IP和端口、HTTP协议版本、客户端的IP和端口等，如下图所示。</p><p><img src="https://user-images.githubusercontent.com/16996753/53460264-7762e580-3a77-11e9-82ec-39b06b693bd1.png" alt="image"></p><p>mitmproxy还提供了命令行式的编辑功能，我们可以在此页面中重新编辑请求。敲击e键即可进入编辑功能，这时它会询问你要编辑哪部分内容，如Cookies、Query、URL等，每个选项的第一个字母会高亮显示。敲击要编辑内容名称的首字母即可进入该内容的编辑页面，如敲击m即可编辑请求的方式，敲击q即可修改GET请求参数Query。</p><p>这时我们敲击q，进入到编辑Query的页面。由于没有任何参数，我们可以敲击a来增加一行，然后就可以输入参数对应的Key和Value，如下图所示。</p><p><img src="https://user-images.githubusercontent.com/16996753/53460278-83e73e00-3a77-11e9-843d-121fa665bb2c.png" alt="image"></p><p>这里我们输入Key为wd，Value为NBA。</p><p>然后再敲击esc键和q键，返回之前的页面，再敲击e和p键修改Path。和上面一样，敲击a增加Path的内容，这时我们将Path修改为s，如下图所示。</p><p><img src="https://user-images.githubusercontent.com/16996753/53460288-8e093c80-3a77-11e9-9be4-9f70a9519524.png" alt="image"></p><p>再敲击esc和q键返回，这时我们可以看到最上面的请求链接变成了：<a href="https://www.baidu.com/s?wd=NBA%E3%80%82%E8%AE%BF%E9%97%AE%E8%BF%99%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E7%99%BE%E5%BA%A6%E6%90%9C%E7%B4%A2NBA%E5%85%B3%E9%94%AE%E8%AF%8D%E7%9A%84%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%E6%89%80%E7%A4%BA%E3%80%82" target="_blank" rel="noopener">https://www.baidu.com/s?wd=NBA。访问这个页面，可以看到百度搜索NBA关键词的搜索结果，如下图所示。</a></p><p><img src="https://user-images.githubusercontent.com/16996753/53460302-98c3d180-3a77-11e9-91b6-38867840cf12.png" alt="image"></p><p>敲击a保存修改，敲击r重新发起修改后的请求，即可看到上方请求方式前面多了一个回旋箭头，这说明重新执行了修改后的请求。这时我们再观察响应体内容，即可看到搜索NBA的页面结果的源代码，如下图所示。</p><p><img src="https://user-images.githubusercontent.com/16996753/53460305-a5e0c080-3a77-11e9-8433-e3767ba86e20.png" alt="image"></p><p>以上内容便是mitmproxy的简单用法。利用mitmproxy，我们可以观察到手机上的所有请求，还可以对请求进行修改并重新发起。</p><p>Fiddler、Charles也有这个功能，而且它们的图形界面操作更加方便。那么mitmproxy的优势何在？</p><p>mitmproxy的强大之处体现在它的另一个工具mitmdump，有了它我们可以直接对接Python对请求进行处理。下面我们来看看mitmdump的用法。</p><h1 id="六-mitmdump的使用">六、mitmdump的使用</h1><hr><p>mitmdump是mitmproxy的命令行接口，同时还可以对接Python对请求进行处理，这是相比Fiddler、Charles等工具更加方便的地方。有了它我们可以不用手动截获和分析HTTP请求和响应，只需写好请求和响应的处理逻辑即可。它还可以实现数据的解析、存储等工作，这些过程都可以通过Python实现。</p><h2 id="1-实例引入">1. 实例引入</h2><hr><p>我们可以使用命令启动mitmproxy，并把截获的数据保存到文件中，命令如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mitmdump -w outfile</span><br></pre></td></tr></table></figure><p>其中outfile的名称任意，截获的数据都会被保存到此文件中。</p><p>还可以指定一个脚本来处理截获的数据，使用-s参数即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mitmdump -s script.py</span><br></pre></td></tr></table></figure><p><a href="http://xn--script-vy7ihu55yfpr8vg1omb7ltso830csz5bmn0cwlh.py" target="_blank" rel="noopener">这里指定了当前处理脚本为script.py</a>，它需要放置在当前命令执行的目录下。</p><p>我们可以在脚本里写入如下的代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def request(flow):</span><br><span class="line">    flow.request.headers['User-Agent'] = 'MitmProxy'</span><br><span class="line">    print(flow.request.headers)</span><br></pre></td></tr></table></figure><p>我们定义了一个request()方法，参数为flow，它其实是一个HTTPFlow对象，通过request属性即可获取到当前请求对象。然后打印输出了请求的请求头，将请求头的User-Agent修改成了MitmProxy。</p><p>运行之后我们在手机端访问http://httpbin.org/get，可以看到如下情况发生。</p><p>手机端的页面显示如下图所示。<br><img src="https://user-images.githubusercontent.com/16996753/53460361-d163ab00-3a77-11e9-8a36-0fbc600137b7.png" alt="image"></p><p>PC端控制台输出如下图所示。<br><img src="https://user-images.githubusercontent.com/16996753/53460370-daed1300-3a77-11e9-9cbb-3b7c30be4ad7.png" alt="image"></p><p>手机端返回结果的Headers实际上就是请求的Headers，User-Agent被修改成了mitmproxy。PC端控制台输出了修改后的Headers内容，其User-Agent的内容正是mitmproxy。</p><p>所以，通过这三行代码我们就可以完成对请求的改写。print()方法输出结果可以呈现在PC端控制台上，可以方便地进行调试。</p><h2 id="2-日志输出">2. 日志输出</h2><hr><p>mitmdump提供了专门的日志输出功能，可以设定不同级别以不同颜色输出结果。我们把脚本修改成如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from mitmproxy import ctx</span><br><span class="line"></span><br><span class="line">def request(flow):</span><br><span class="line">    flow.request.headers[&apos;User-Agent&apos;] = &apos;MitmProxy&apos;</span><br><span class="line">    ctx.log.info(str(flow.request.headers))</span><br><span class="line">    ctx.log.warn(str(flow.request.headers))</span><br><span class="line">    ctx.log.error(str(flow.request.headers))</span><br></pre></td></tr></table></figure><p>这里调用了ctx模块，它有一个log功能，调用不同的输出方法就可以输出不同颜色的结果，以方便我们做调试。例如，info()方法输出的内容是白色的，warn()方法输出的内容是黄色的，error()方法输出的内容是红色的。运行结果如下图所示。</p><p><img src="https://user-images.githubusercontent.com/16996753/53460406-0243e000-3a78-11e9-9fc2-6582d885369e.png" alt="image"></p><p>不同的颜色对应不同级别的输出，我们可以将不同的结果合理划分级别输出，以更直观方便地查看调试信息。</p><h2 id="3-request">3. Request</h2><hr><p>最开始我们实现了request()方法并且对Headers进行了修改。下面我们来看看Request还有哪些常用的功能。我们先用一个实例来感受一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from mitmproxy import ctx</span><br><span class="line"></span><br><span class="line">def request(flow):</span><br><span class="line">    request = flow.request</span><br><span class="line">    info = ctx.log.info</span><br><span class="line">    info(request.url)</span><br><span class="line">    info(str(request.headers))</span><br><span class="line">    info(str(request.cookies))</span><br><span class="line">    info(request.host)</span><br><span class="line">    info(request.method)</span><br><span class="line">    info(str(request.port))</span><br><span class="line">    info(request.scheme)</span><br></pre></td></tr></table></figure><p>我们修改脚本，然后在手机上打开百度，即可看到PC端控制台输出了一系列的请求，在这里我们找到第一个请求。控制台打印输出了Request的一些常见属性，如URL、Headers、Cookies、Host、Method、Scheme等。输出结果如下图所示。</p><p><img src="https://user-images.githubusercontent.com/16996753/53460441-1851a080-3a78-11e9-9766-7da3fcb579ea.png" alt="image"></p><p>结果中分别输出了请求链接、请求头、请求Cookies、请求Host、请求方法、请求端口、请求协议这些内容。</p><p>同时我们还可以对任意属性进行修改，就像最初修改Headers一样，直接赋值即可。例如，这里将请求的URL修改一下，脚本修改如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def request(flow):</span><br><span class="line">    url = &apos;https://httpbin.org/get&apos;</span><br><span class="line">    flow.request.url = url</span><br></pre></td></tr></table></figure><p>手机端得到如下结果，如下图所示。<br><img src="https://user-images.githubusercontent.com/16996753/53460464-29021680-3a78-11e9-8407-97ff08b4edf9.png" alt="image"></p><p>比较有意思的是，浏览器最上方还是呈现百度的URL，但是页面已经变成了httpbin.org的页面了。另外，Cookies明显还是百度的Cookies。我们只是用简单的脚本就成功把请求修改为其他的站点。通过这种方式修改和伪造请求就变得轻而易举。</p><p>通过这个实例我们知道，有时候URL虽然是正确的，但是内容并非是正确的。我们需要进一步提高自己的安全防范意识。</p><p>Request还有很多属性，在此不再一一列举。更多属性可以参考：<a href="http://docs.mitmproxy.org/en/latest/scripting/api.html%E3%80%82" target="_blank" rel="noopener">http://docs.mitmproxy.org/en/latest/scripting/api.html。</a></p><p>只要我们了解了基本用法，会很容易地获取和修改Reqeust的任意内容，比如可以用修改Cookies、添加代理等方式来规避反爬。</p><h2 id="4-response">4. Response</h2><hr><p>对于爬虫来说，我们更加关心的其实是Response的内容，因为Response Body才是爬取的结果。对于Response来说，mitmdump也提供了对应的处理接口，就是response()方法。下面我们用一个实例感受一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from mitmproxy import ctx</span><br><span class="line"></span><br><span class="line">def response(flow):</span><br><span class="line">    response = flow.response</span><br><span class="line">    info = ctx.log.info</span><br><span class="line">    info(str(response.status_code))</span><br><span class="line">    info(str(response.headers))</span><br><span class="line">    info(str(response.cookies))</span><br><span class="line">    info(str(response.text))</span><br></pre></td></tr></table></figure><p>将脚本修改为如上内容，然后手机访问：<a href="http://httpbin.org/get%E3%80%82" target="_blank" rel="noopener">http://httpbin.org/get。</a></p><p>这里打印输出了Response的status_code、headers、cookies、text这几个属性，其中最主要的text属性就是网页的源代码。</p><p>PC端控制台输出如下图所示。<br><img src="https://user-images.githubusercontent.com/16996753/53460481-420ac780-3a78-11e9-9697-51ea32ba6670.png" alt="image"></p><p>控制台输出了Response的状态码、响应头、Cookies、响应体这几部分内容。</p><p>我们可以通过response()方法获取每个请求的响应内容。接下来再进行响应的信息提取和存储，我们就可以成功完成爬取了。</p><hr><p>Reference：</p><blockquote><p>GitHub Repo：<a href="https://github.com/CoderTonyChan/CoderTonyChan.github.io" target="_blank" rel="noopener">Tony Studio</a></p><p>Follow: <a href="https://github.com/CoderTonyChan" target="_blank" rel="noopener">CoderTonyCHan · GitHub</a></p></blockquote>]]></content:encoded>
      
      <comments>https://blog.tonystudio.ml/2018/04/30/HTTPS-mitmproxy/#disqus_thread</comments>
    </item>
    
    <item>
      <title>2017 年总结</title>
      <link>https://blog.tonystudio.ml/2018/01/01/2017-summary/</link>
      <guid>https://blog.tonystudio.ml/2018/01/01/2017-summary/</guid>
      <pubDate>Sun, 31 Dec 2017 16:15:22 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;2017年走过人生中最重要的三件大事：买房、结婚、生子。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;2017总结&quot;&gt;2017总结&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;学习方法的总结：&lt;/p&gt;
&lt;p&gt;联系 - 发现 - 重组&lt;/p&gt;
&lt;p&gt;在学校，我
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>2017年走过人生中最重要的三件大事：买房、结婚、生子。</p></blockquote><h1 id="2017总结">2017总结</h1><hr><p>学习方法的总结：</p><p>联系 - 发现 - 重组</p><p>在学校，我们学习的是技法，但是并不会教会我们智慧 (智慧是靠自己悟出来的)。</p><p>人民的名义</p><p>寒门再难出贵子</p><p>从《人民的名义》观照现实婚姻</p><p>Begin again - 拍摄是谱曲，后期是演奏</p><hr><p>Reference：</p><blockquote><p>GitHub Repo：<a href="https://github.com/CoderTonyChan/CoderTonyChan.github.io" target="_blank" rel="noopener">Tony Studio</a></p><p>Follow: <a href="https://github.com/CoderTonyChan" target="_blank" rel="noopener">CoderTonyCHan · GitHub</a></p></blockquote>]]></content:encoded>
      
      <comments>https://blog.tonystudio.ml/2018/01/01/2017-summary/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Nginx配置</title>
      <link>https://blog.tonystudio.ml/2017/06/26/nginx-collect/</link>
      <guid>https://blog.tonystudio.ml/2017/06/26/nginx-collect/</guid>
      <pubDate>Mon, 26 Jun 2017 02:51:24 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;nginx在工作中已经有好几个环境在使用了，每次都是重新去网上扒博客，各种编译配置，今天自己也整理一份安装文档和nginx.conf配置选项的说明，留作以后参考。像负载均衡配置（包括健康检查）、缓存（包括清空缓存）配置实例，请参考 &lt;a href=&quot;http://segme
        
      
      </description>
      
      <content:encoded><![CDATA[<p>nginx在工作中已经有好几个环境在使用了，每次都是重新去网上扒博客，各种编译配置，今天自己也整理一份安装文档和nginx.conf配置选项的说明，留作以后参考。像负载均衡配置（包括健康检查）、缓存（包括清空缓存）配置实例，请参考 <a href="http://segmentfault.com/a/1190000002873747" target="_blank" rel="noopener">http://segmentfault.com/a/1190000002873747</a> ，ssl加密请参考 <a href="http://seanlook.com/2015/05/28/nginx-ssl/" target="_blank" rel="noopener">http://seanlook.com/2015/05/28/nginx-ssl/</a> 。</p><p><img src="https://segmentfault.com/img/remote/1460000015385948" alt=""></p><h1 id="nginx常用配置">Nginx常用配置</h1><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  dev-admin.paascloud.net;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://localhost:7020;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  dev-login.paascloud.net;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://localhost:7010;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  dev-mall.paascloud.net;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://localhost:7030;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  dev-api.paascloud.net;</span><br><span class="line">    location ~ &#123;</span><br><span class="line">        proxy_pass   http://localhost:7979;</span><br><span class="line">    &#125;</span><br><span class="line">    error_page   500 502 503 504  /50x.html;</span><br><span class="line">    location = /50x.html &#123;</span><br><span class="line">        root   html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="nginx配置文件的整体结构">Nginx配置文件的整体结构</h1><hr><p><img src="https://segmentfault.com/img/remote/1460000015385949" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">user  nobody  nobody;</span><br><span class="line">worker_processes  3;</span><br><span class="line">error_log  logs/error.log;</span><br><span class="line">pid  logs/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    use epoll;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;</span><br><span class="line">    access_log  logs/access.log  main;</span><br><span class="line">    sendfile  on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       8088;</span><br><span class="line">        server_name  codesheep;</span><br><span class="line">        access_log  /codesheep/webserver/server1/log/access.log;</span><br><span class="line">        error_page  404  /404.html;</span><br><span class="line"></span><br><span class="line">        location /server1/location1 &#123;</span><br><span class="line">            root   /codesheep/webserver;</span><br><span class="line">            index  index.server2-location1.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location /server1/location2 &#123;</span><br><span class="line">        root   /codesheep/webserver;</span><br><span class="line">            index  index.server2-location2.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen       8089;</span><br><span class="line">        server_name  192.168.31.177;</span><br><span class="line">        access_log  /codesheep/webserver/server2/log/access.log;</span><br><span class="line">        error_page  404  /404.html;</span><br><span class="line">        </span><br><span class="line">        location /server2/location1 &#123;</span><br><span class="line">            root   /codesheep/webserver;</span><br><span class="line">            index  index.server2-location1.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location /srv2/loc2 &#123;</span><br><span class="line">            alias   /codesheep/webserver/server2/location2/;</span><br><span class="line">            index  index.server2-location2.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        location = /404.html &#123;</span><br><span class="line">            root /codesheep/webserver/;</span><br><span class="line">            index 404.html;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="nginx常见错误及处理方法">Nginx常见错误及处理方法</h1><hr><h2 id="404-bad-request">404 bad request</h2><hr><p>一般原因:请求的Header过大</p><p>解决方法：配置nginx.conf相关设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">client_header_buffer_size 16k;</span><br><span class="line">large_client_header_buffers 4 64k;</span><br></pre></td></tr></table></figure><h2 id="500-internal-server-rrror">500 Internal Server Rrror</h2><hr><p>一般原因：</p><p>脚本错误，（php语法错误、lua语法错误）</p><p>访问量过大，系统资源限制，不能打开过多文件</p><p>磁盘空间不足。（access log开启可能导致磁盘满溢 关闭）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">worker_rlimit_nofile 65535;</span><br><span class="line">* soft nofile 65535</span><br><span class="line">* hard nofile 65535</span><br></pre></td></tr></table></figure><hr><p>Reference：</p><blockquote><p>GitHub Repo：<a href="https://github.com/CoderTonyChan/CoderTonyChan.github.io" target="_blank" rel="noopener">Tony Studio</a></p><p>Follow: <a href="https://github.com/CoderTonyChan" target="_blank" rel="noopener">CoderTonyCHan · GitHub</a></p></blockquote>]]></content:encoded>
      
      <comments>https://blog.tonystudio.ml/2017/06/26/nginx-collect/#disqus_thread</comments>
    </item>
    
    <item>
      <title>cocopods的坑</title>
      <link>https://blog.tonystudio.ml/2017/02/21/cocopods-collect/</link>
      <guid>https://blog.tonystudio.ml/2017/02/21/cocopods-collect/</guid>
      <pubDate>Tue, 21 Feb 2017 02:51:24 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;使用CocoaPods也有很长一段时间了，最近几个月的时间里也主导了公司私有Pods的创建和使用。在此期间踩过了不少坑，在踩坑的过程中也收获了不少经验，更加熟练地掌握了CocoaPods的一些指令的使用。本篇作为这段时间收获的备忘。&lt;/p&gt;
&lt;h1 id=&quot;多target时
        
      
      </description>
      
      <content:encoded><![CDATA[<p>使用CocoaPods也有很长一段时间了，最近几个月的时间里也主导了公司私有Pods的创建和使用。在此期间踩过了不少坑，在踩坑的过程中也收获了不少经验，更加熟练地掌握了CocoaPods的一些指令的使用。本篇作为这段时间收获的备忘。</p><h1 id="多target时podfile该如何写">多target时Podfile该如何写</h1><hr><p>我的建议是使用Ruby语法，定义不同的分组，然后不同的target可以自由选择依赖哪些分组，这种方式看起来更简洁，对于多target的项目来说也更友好：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">platform :ios, &apos;8.0&apos;</span><br><span class="line"></span><br><span class="line">def commonPods #通用pods集</span><br><span class="line">    pod &apos;AFNetworking&apos;, &apos;~&gt; 2.0&apos;</span><br><span class="line">    pod &apos;Masonry&apos;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">def appOnlyPods #app专用pods集</span><br><span class="line">    pod &apos;MBProgressHUD&apos;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">def extensionPods #扩展专用pods集</span><br><span class="line">    pod &apos;GTSDKExtension&apos;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target :TestCocoaPods do</span><br><span class="line">    commonPods</span><br><span class="line">    appOnlyPods</span><br><span class="line"></span><br><span class="line">    target :TestCocoaPodsTests do</span><br><span class="line">    inherit! :search_paths</span><br><span class="line">    # Pods for testing</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    target :TestCocoaPodsUITests do</span><br><span class="line">        inherit! :search_paths</span><br><span class="line">        # Pods for testing</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">target :SecondTarget do</span><br><span class="line">    commonPods</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h1 id="如何忽略pods警告">如何忽略Pods警告？</h1><hr><p>有些第三方Pod集成进来会有一大堆警告信息，如果你看着比较难受想把它忽略的话，在Podfile中对应的target或分组下加上关键字inhibit_all_warnings即可。</p><h1 id="如何直接引用第三方库中的头文件">如何直接引用第三方库中的头文件？</h1><hr><p>在用CocoaPods集成第三方库之后，默认情况下，我们需要使用类似#import &lt;XXX/YYY.h&gt;的方式引入第三方库的头文件。我们可以在Build Settings -&gt; User Header Search Paths中添加${SRCROOT}并设置成recursive，这样我们就可以直接使用#impot &quot;YYY.h&quot;这种方式了。</p><h1 id="修改pods中的源码为什么不生效">修改pods中的源码,为什么不生效?</h1><hr><p>每次编译编译器默认是不会再次编译pods中的代码, 修改后可以clean一下,然后再试</p><hr><p>Reference：</p><blockquote><p>GitHub Repo：<a href="https://github.com/CoderTonyChan/CoderTonyChan.github.io" target="_blank" rel="noopener">Tony Studio</a></p><p>Follow: <a href="https://github.com/CoderTonyChan" target="_blank" rel="noopener">CoderTonyCHan · GitHub</a></p></blockquote>]]></content:encoded>
      
      <comments>https://blog.tonystudio.ml/2017/02/21/cocopods-collect/#disqus_thread</comments>
    </item>
    
    <item>
      <title>个人建站教程</title>
      <link>https://blog.tonystudio.ml/2016/10/24/build-tonystudio.ml/</link>
      <guid>https://blog.tonystudio.ml/2016/10/24/build-tonystudio.ml/</guid>
      <pubDate>Mon, 24 Oct 2016 03:11:24 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;个人建站教程&lt;br&gt;
服务器 -&amp;gt; 域名 -&amp;gt; DNS提供 -&amp;gt; SSL证书&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://pn9jzw2t9.bkt.clouddn.com/2019/build-t
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>个人建站教程<br>服务器 -&gt; 域名 -&gt; DNS提供 -&gt; SSL证书</p></blockquote><p><img src="http://pn9jzw2t9.bkt.clouddn.com/2019/build-tonystudio.1.png" alt=""></p><h1 id="服务器">服务器</h1><hr><p>推荐使用阿里云 , 或者 GCP 一年免费撸</p><h2 id="免密码登录">免密码登录</h2><hr><p>方法一</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@112.74.34.46 'mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys' &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>方法二<br>使用阿里的密钥对 pem文件</p><p>.ssh/config</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host tonyos</span><br><span class="line">HostName 112.74.34.46</span><br><span class="line">User root</span><br><span class="line">IdentitiesOnly yes</span><br></pre></td></tr></table></figure><p>连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh tonyos</span><br></pre></td></tr></table></figure><h1 id="免费域名申请及使用">免费域名申请及使用</h1><hr><p>Freenom 提供一下后缀的免费域名：.TK   .ML  .GA   .CF   .GQ</p><h2 id="申请">申请</h2><hr><p>打开 <a href="http://freenom.com" target="_blank" rel="noopener">freenom.com</a>，在网站中输入你想要的域名，检查可用性。</p><p><img src="https://user-images.githubusercontent.com/16996753/53398005-8dbf6180-39e3-11e9-8dc7-cfa64969406b.png" alt="image"></p><p><img src="https://user-images.githubusercontent.com/16996753/53398024-9748c980-39e3-11e9-9ea6-5531dba9253a.jpg" alt="a5d80bda-5cbb-4487-a542-3926c79d96e7"></p><p><img src="https://user-images.githubusercontent.com/16996753/53398034-9dd74100-39e3-11e9-803b-bb77ce12d9ce.jpg" alt="26b4efea-ed08-4174-a4fe-32fa6ce4307e"></p><p><img src="https://user-images.githubusercontent.com/16996753/53398043-a2035e80-39e3-11e9-9c56-7d5483480d6b.jpg" alt="aa59dc75-d13e-43a2-acab-88d0c3a4e4a7"></p><h2 id="nameserver">NameServer</h2><hr><p><img src="https://user-images.githubusercontent.com/16996753/53398084-bba4a600-39e3-11e9-86db-131c59b73a4e.jpg" alt="ed0ab057-6e74-4d68-b2b4-6861c706d7f4"><br><img src="https://user-images.githubusercontent.com/16996753/53398091-be9f9680-39e3-11e9-9da4-5e0c0683173b.jpg" alt="c66432d2-8a38-41e1-9433-06dce4ce1f84"><br><img src="https://user-images.githubusercontent.com/16996753/53398099-c2331d80-39e3-11e9-9acf-c2dae9213f7a.jpg" alt="6042df45-4f02-4103-8322-2a8199d2c5df"><br><img src="https://user-images.githubusercontent.com/16996753/53398104-c5c6a480-39e3-11e9-9121-e7f0d9961523.jpg" alt="39da4a41-e57f-4dd5-9e5b-b03c03e5fbe3"><br><img src="https://user-images.githubusercontent.com/16996753/53398119-ccedb280-39e3-11e9-8aff-7b12e2aeff7b.jpg" alt="e041ee28-c61c-4be2-96f4-a69c29be8615"></p><h1 id="dns">DNS</h1><hr><p>可以使用QQ账户管理 还能把证书托管在上面管理</p><p><a href="https://www.dnspod.cn/" target="_blank" rel="noopener">https://www.dnspod.cn/</a></p><h1 id="ssl证书">SSL证书</h1><hr><p>提供商 Let’s Encrypt</p><p>申请工具 <a href="https://freessl.cn" target="_blank" rel="noopener">https://freessl.cn</a> 免费的 但是只有3个月</p><h1 id="域名自动续期">域名自动续期</h1><hr><p>免费证书不存在续期这个说法，您只能重新申请一张新的证书。</p><h2 id="使用freesslcn"><a href="http://xn--freessl-oc6k521z.cn" target="_blank" rel="noopener">使用freessl.cn</a></h2><hr><p>DNS验证经常验证不了</p><p><img src="https://user-images.githubusercontent.com/16996753/53869755-c8547a00-4033-11e9-87f1-ed391baa2df0.png" alt="ce6edbb5-a749-42c0-bda5-2a11b69d6390"></p><p>本地DNS验证可以使用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig -t txt _acme-challenge.tonystudio.ml</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> nslookup tonystudio.ml </span><br><span class="line">Server:40.73.101.101</span><br><span class="line">Address:40.73.101.101#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">tonystudio.mlcanonical name = codertonychan.github.io.</span><br><span class="line">Name:codertonychan.github.io</span><br><span class="line">Address: 185.199.109.153</span><br><span class="line">Name:codertonychan.github.io</span><br><span class="line">Address: 185.199.111.153</span><br><span class="line">Name:codertonychan.github.io</span><br><span class="line">Address: 185.199.110.153</span><br><span class="line">Name:codertonychan.github.io</span><br><span class="line">Address: 185.199.108.153</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> nslookup tonystudio.ml 114.114.114.114</span><br><span class="line">Server:114.114.114.114</span><br><span class="line">Address:114.114.114.114#53</span><br><span class="line"></span><br><span class="line">Non-authoritative answer:</span><br><span class="line">tonystudio.mlcanonical name = codertonychan.github.io.</span><br><span class="line">Name:codertonychan.github.io</span><br><span class="line">Address: 185.199.111.153</span><br><span class="line">Name:codertonychan.github.io</span><br><span class="line">Address: 185.199.110.153</span><br><span class="line">Name:codertonychan.github.io</span><br><span class="line">Address: 185.199.109.153</span><br><span class="line">Name:codertonychan.github.io</span><br><span class="line">Address: 185.199.108.153</span><br></pre></td></tr></table></figure><p><a href="http://xn--MySSL-2b3hs1jk87a4ti5w3c87ya.com" target="_blank" rel="noopener">或者使用工具MySSL.com</a></p><p>Mac下能用工具集</p><p><img src="https://user-images.githubusercontent.com/16996753/53870953-313cf180-4036-11e9-9065-70cbdc641dd6.png" alt="image"></p><h2 id="使用mysslcom"><a href="http://xn--MySSL-2b3hr36t.com" target="_blank" rel="noopener">使用MySSL.com</a></h2><ul><li><p><a href="https://myssl.com/tonystudio.ml?domain=tonystudio.ml&amp;status=q&amp;f=1" target="_blank" rel="noopener">网站安全性报告</a></p></li><li><p><a href="https://myssl.com/dns_check.html#dns_check" target="_blank" rel="noopener">DNS 诊断工具</a></p></li></ul><h2 id="使用sslforfree">使用sslforfree</h2><hr><p>这个是先验证后操作 不存在会验证失败的问题</p><p>免费的DNS 只能设置 600 TTL 最多等待5分钟</p><p>这个有Renew功能 推荐</p><p><img src="https://user-images.githubusercontent.com/16996753/53869890-14072380-4034-11e9-989e-99225bb62044.png" alt="image"></p><p>同一个签证完后 会有2个不同的日期 很奇怪 而且和之前的对不上</p><p><img src="https://user-images.githubusercontent.com/16996753/53870084-7a8c4180-4034-11e9-9bd5-2df54dd0826c.png" alt="image"><br><img src="https://user-images.githubusercontent.com/16996753/53870097-80822280-4034-11e9-9583-a95e03b4a2c8.png" alt="image"></p><h2 id="证书托管">证书托管</h2><hr><p>推荐腾讯云的<a href="https://console.cloud.tencent.com/ssl" target="_blank" rel="noopener">SSL证书管理</a></p><p>另外证书也会备份一份iCloud</p><h1 id="图床推荐">图床推荐</h1><hr><p>我常用的图床 微博不能上传png 不支持透明</p><h2 id="github-gist">GitHub Gist</h2><hr><p>私有api 5000/每小时/ip 需要定期更新</p><h2 id="github-issue">GitHub Issue</h2><hr><p>直接粘贴就可以上传了</p><h2 id="七牛云">七牛云</h2><hr><p>每月10G免费流量</p><hr><p>Reference：</p><blockquote><p>GitHub Repo：<a href="https://github.com/CoderTonyChan/CoderTonyChan.github.io" target="_blank" rel="noopener">Tony Studio</a></p><p>Follow: <a href="https://github.com/CoderTonyChan" target="_blank" rel="noopener">CoderTonyCHan · GitHub</a></p></blockquote>]]></content:encoded>
      
      <comments>https://blog.tonystudio.ml/2016/10/24/build-tonystudio.ml/#disqus_thread</comments>
    </item>
    
    <item>
      <title>HTTP/HTTPS 抓包 ---- Charles</title>
      <link>https://blog.tonystudio.ml/2016/09/18/HTTPS-Charles/</link>
      <guid>https://blog.tonystudio.ml/2016/09/18/HTTPS-Charles/</guid>
      <pubDate>Sun, 18 Sep 2016 02:51:24 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;网上数据抓包,在当前抓包工具横行的时代,对于一个IT开发者来说,是一个很简单的必备的技能,例如青花瓷(Charles)等等工具.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://pn9jzw2t9.bkt.clouddn
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>网上数据抓包,在当前抓包工具横行的时代,对于一个IT开发者来说,是一个很简单的必备的技能,例如青花瓷(Charles)等等工具.</p></blockquote><p><img src="http://pn9jzw2t9.bkt.clouddn.com/2019/chales-collect.2.png" alt=""></p><h1 id="https通讯过程">https通讯过程</h1><hr><p>在讲https抓包之前,必须要了解https的整个校验和通信过程,我们就简单的精简的画一下重要的过程,至于什么三个随机数或者通信秘钥的生成就不详细介绍,主要是针对讲一下https的中间人攻击(https抓包的实现基础)过程</p><p align="center"><img src="https://upload-images.jianshu.io/upload_images/5505686-68a34f7acfa8ebf3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/825"></p><p>在这个过程中,正常的话,如果哪个步骤出现问题,链接都会停止,无法进行通信,这个是https简单的校验的一个过程介绍.</p><p>那么,https在抓包工具中是如何实现抓包的呢?<br>抓包工具就是在上面的过程中,证书认证生成通信密钥中做了手脚.<br>以青花瓷为例,大家使用青花瓷抓http请求时,由于没有做安全校验,很容易就实现了数据拦截和转发,至于https呢?</p><h1 id="中间人攻击的情形">中间人攻击的情形</h1><hr><p>抓取https包的时候,青花瓷会要求使用者 对抓包的设备(手机或其他设备)<br>,安装一个证书,安装这个证书的时候,其实是安装了一个根证书(允许颁发CA的一个证书机构的根证书),当你安装了该根证书之后,该证书机构颁发的其他证书,默认都会被你的系统所信任,这个就是青花瓷完成https抓包的一个重要前提!!</p><p align="center"><img src="https://upload-images.jianshu.io/upload_images/5505686-d95be6d0815def28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/980"></p><p>当客户端设置了代理,并且开始发出网络请求的时候,这个网络请求的校验过程就会变成这样</p><p align="center"><img src="https://upload-images.jianshu.io/upload_images/5505686-1c2bb870ed73506f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000"></p><ul><li>当客户端Client对服务器Server发送请求(带着随机数和加密算法),由于青花瓷做了代理,请求被青花瓷拦截,处理(青花瓷的角色现在对于Client来说是服务器),青花瓷将客户端带的随机数和加密算法处理,然后返回自己的证书通过客户端校验,获取到客户端提交的请求参数等数据,</li><li>青花瓷作为客户端(自己去产生随机数和携带支持的加密算法)去请求刚刚Client想要请求的Server,然后,Server会和青花瓷完成上面讲的那个完整的校验,并且读取青花瓷带错来的具体请求,返回正常的数据结果.</li><li>青花瓷得到服务器数据的返回结果之后,开始继续和过程1中的Client以服务器的身份,去做处理,首先收到客户端的随机数和加密算法,自己生成一个随机数和选择一个客户端的加密算法,然后<strong><strong><strong><strong><em>重要</em></strong></strong></strong></strong>* 青花瓷会返回一个伪造的CA证书(公钥和真实的server不一样,但是域名是一样的,或者说,除了域名是一致的,其他的都不是一致的,而且这个签发机构是青花瓷之前让你安装的根证书 签发的,所以,当返回这个证书的时候,你的客户端的信任链是可以完成的,会被系统信任),然后Client在这个伪造的证书(对于青花瓷和Client是真实证书(验证信任链和证书信息都通过了),但是和真实的域名对应的证书来看,是伪造证书)的基础上,和青花瓷通信,然后青花瓷再和Server通信,成了一个中间人的角色,这样,整个过程的数据传输,都被青花瓷给监听到了,在此,中间人攻击的过程 就完成了</li></ul><h1 id="如何防止被抓包">如何防止被抓包</h1><hr><p>当进行网络请求的时候,客户端判断当前是否设置了代理,如果设置了代理,不允许进行访问(不知道微信浏览器 里面 是不是这样实现的,微信里面 设置了代理看公众号等信息就都不允许看了,无法访问)<br>附带判断是否设置代理的代码:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)getProxyStatus &#123;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *proxySettings = <span class="built_in">NSMakeCollectable</span>([(<span class="built_in">NSDictionary</span> *)<span class="built_in">CFNetworkCopySystemProxySettings</span>() autorelease]);</span><br><span class="line">    <span class="built_in">NSArray</span> *proxies = <span class="built_in">NSMakeCollectable</span>([(<span class="built_in">NSArray</span> *)<span class="built_in">CFNetworkCopyProxiesForURL</span>((<span class="built_in">CFURLRef</span>)[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.google.com"</span>], (<span class="built_in">CFDictionaryRef</span>)proxySettings) autorelease]);</span><br><span class="line">    <span class="built_in">NSDictionary</span> *settings = [proxies objectAtIndex:<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"host=%@"</span>, [settings objectForKey:(<span class="built_in">NSString</span> *)kCFProxyHostNameKey]);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"port=%@"</span>, [settings objectForKey:(<span class="built_in">NSString</span> *)kCFProxyPortNumberKey]);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"type=%@"</span>, [settings objectForKey:(<span class="built_in">NSString</span> *)kCFProxyTypeKey]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([[settings objectForKey:(<span class="built_in">NSString</span> *)kCFProxyTypeKey] isEqualToString:<span class="string">@"kCFProxyTypeNone"</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//没有设置代理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//设置代理了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端本地做证书校验,并且设置不仅仅校验公钥,设置完整的正式校验模式</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+(AFSecurityPolicy*)customSecurityPolicy</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// /先导入证书</span></span><br><span class="line">    <span class="built_in">NSString</span> *cerPath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"test"</span> ofType:<span class="string">@"cer"</span>];<span class="comment">//证书的路径</span></span><br><span class="line">    <span class="built_in">NSData</span> *certData = [<span class="built_in">NSData</span> dataWithContentsOfFile:cerPath];</span><br><span class="line">    <span class="comment">// AFSSLPinningModeCertificate 使用证书验证模式 (AFSSLPinningModeCertificate是证书所有字段都一样才通过认证，AFSSLPinningModePublicKey只认证公钥那一段，AFSSLPinningModeCertificate更安全。但是单向认证不能防止“中间人攻击”)</span></span><br><span class="line">    AFSecurityPolicy *securityPolicy = [AFSecurityPolicy policyWithPinningMode:AFSSLPinningModeCertificate];</span><br><span class="line">    <span class="comment">// allowInvalidCertificates 是否允许无效证书（也就是自建的证书），默认为NO</span></span><br><span class="line">    <span class="comment">// 如果是需要验证自建证书，需要设置为YES</span></span><br><span class="line">    securityPolicy.allowInvalidCertificates = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//validatesDomainName 是否需要验证域名，默认为YES；</span></span><br><span class="line">    <span class="comment">//假如证书的域名与你请求的域名不一致，需把该项设置为NO；如设成NO的话，即服务器使用其他可信任机构颁发的证书，也可以建立连接，这个非常危险，建议打开。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//置为NO，主要用于这种情况：客户端请求的是子域名，而证书上的是另外一个域名。因为SSL证书上的域名是独立的，假如证书上注册的域名是www.google.com，那么mail.google.com是无法验证通过的；当然，有钱可以注册通配符的域名*.google.com，但这个还是比较贵的。</span></span><br><span class="line">    <span class="comment">//如置为NO，建议自己添加对应域名的校验逻辑。</span></span><br><span class="line">    securityPolicy.validatesDomainName = <span class="literal">YES</span>;</span><br><span class="line">    <span class="built_in">NSSet</span>&lt;<span class="built_in">NSData</span>*&gt; * set = [[<span class="built_in">NSSet</span> alloc]initWithObjects:certData  , <span class="literal">nil</span>];</span><br><span class="line">    securityPolicy.pinnedCertificates = set;</span><br><span class="line">    </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> securityPolicy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话,证书会校验请求的时候不仅仅校验域名,会将证书中的公钥及其他信息也进行校验,这样的话,中间人伪造的证书就无法通过验证,无法进行抓包</p><h1 id="如何抓包">如何抓包</h1><hr><p>要掌握 HTTP ，就需要先看到 HTTP 到底长什么样？（不了解「<a href="http://baike.baidu.com/view/1868389.htm" target="_blank" rel="noopener">网络七层协议模型</a>」和 TCP 的同学先不着急，本系列的后面几篇会涉及到。）</p><h2 id="1-安装-http-抓包工具">1、安装 HTTP 抓包工具</h2><hr><p>在 Chrome 开发者工具下我们可以看到，打开一个网页后，浏览器会发起许多 HTTP 的请求（HTTP Request），这些请求经过服务器端处理后会返回对应的数据（HTTP Response），浏览器会按照这些数据的类型将它们渲染出来。</p><p><img src="https://cloud.githubusercontent.com/assets/344283/11622992/b61edff4-9d04-11e5-8b32-7552bb35371b.png" alt="Chrome Network Panel"></p><p>Chrome 中看到的 Request/Response Header 是其格式化之后的形式，要看到它们的原始模样（Raw Source），我们需要借助两个 HTTP 接口调试利器。</p><p>其中 Windows 系统下使用 <a href="http://www.telerik.com/fiddler" target="_blank" rel="noopener">Fiddler</a>，Mac 系统下使用 <a href="https://www.charlesproxy.com/download/" target="_blank" rel="noopener">Charles</a>。Fiddler 具体的安装与使用教程，请自行百度（安装 Fiddler4 还需同时安装 <a href="http://www.microsoft.com/zh-cn/download/confirmation.aspx?id=17718" target="_blank" rel="noopener">.NET Framework 4</a>），Charles 相关教程，推荐参考 iOS 大神唐巧的《<a href="http://blog.devtang.com/blog/2015/11/14/charles-introduction/" target="_blank" rel="noopener">Charles 从入门到精通</a>》。使用 Linux 系统的说明已经是网络编程方面的大牛了，不需要继续往下看 :P</p><h2 id="2-查看-http-详细报文">2、查看 HTTP 详细报文</h2><hr><p>运行 Fiddler（或 Charles） 之后，使用 Chrome 浏览器打开「猫哥学前班」的新浪微博主页：<a href="http://weibo.com/mgxqb" target="_blank" rel="noopener">http://weibo.com/mgxqb</a></p><p>在 Fiddler 左侧面板下选中该条 HTTP 请求，再将右侧面板的请求部分和响应部分都切换到 Raw 标签页。如下图所示：</p><p><img src="https://cloud.githubusercontent.com/assets/344283/11623001/c7d41f98-9d04-11e5-9463-1ef44694dfa0.png" alt="Fiddler Panel"></p><p>Charles 下的操作与 Fiddler 类似：</p><p><img src="https://cloud.githubusercontent.com/assets/344283/11623009/d7fee63c-9d04-11e5-8f38-b2093c316c54.png" alt="Charles Panel"></p><p><a href="http://www.w3.org/Protocols/" target="_blank" rel="noopener">HTTP 协议规范</a>由 W3C 制定，与具体的抓包工具无关，接下来我们主要以 Charles 为例，详细讲解下 HTTP 的报文格式，这对理解基于 HTTP 的 API 接口设计和网页性能优化有很大帮助。</p><p>我们先看一下请求头的源码（Request Raw），为了防止隐私泄露，我已删除部分 Cookie 信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /mgxqb HTTP/1.1</span><br><span class="line">Host: weibo.com</span><br><span class="line">Cache-Control: max-age=0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.73 Safari/537.36</span><br><span class="line">Accept-Encoding: gzip, deflate, sdch</span><br><span class="line">Accept-Language: en-US,en;q=0.8,zh-CN;q=0.6,zh;q=0.4</span><br><span class="line">Cookie: YF-Page-G0=f70469e0b5607cacf38b47457e34254f; _s_tentry=passport.weibo.com</span><br></pre></td></tr></table></figure><p>仔细观察以上源码，我们能大概总结出 HTTP 协议的格式规范：</p><ul><li>第一行定义了请求类型（<code>GET</code>）、请求路径（<code>/mgxqb</code>）与协议类型及其版本号（<code>HTTP/1.1</code>），使用一个半角空格间隔这三块信息；</li><li>示例源码的最后是两个空行。由于 HTTP 规范中要求一个合法的 HTTP 报文至少包含有一个空行，其中第一个空行用来间隔报文的头部信息（<strong>HTTP Request/Response Header</strong>）和主体信息（<strong>HTTP Request/Response Body</strong>）。在空行的下一行是报文的主体信息，由于本例为 GET 类型请求，其主体（Body）信息通常为空，这便是第二个空行的含义；</li><li>余下的部分有着相同的格式，即 「HTTP Header 字段名+半角冒号+半角空格+值」，我们可以把它看成 <a href="http://baike.baidu.com/view/1479346.htm" target="_blank" rel="noopener">YAML</a> 格式的简易版。其中 HTTP Header 在规范中有着明确的定义，具体参见 <a href="https://zh.wikipedia.org/wiki/HTTP%E5%A4%B4%E5%AD%97%E6%AE%B5%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">HTTP头字段列表</a>。</li></ul><p>这便是一个 HTTP 协议报文的源码格式，以下我们简单讲解下最常见的 HTTP header 的含义。</p><h2 id="3-常见-http-header">3、常见 HTTP header</h2><hr><h3 id="user-agent客户端身份标识">User-Agent：客户端身份标识</h3><hr><p>User-Agent （以下简称 UA）字段记录了访问当前网页的用户浏览器的类型与版本、操作系统类型与版本。根据不同的 UA 信息，提供不同的站点内容是使用 UA 的常见场景。例如，如果用户使用手机访问魅族官网 <a href="http://www.meizu.com%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%9A%E8%87%AA%E5%8A%A8%E8%B7%B3%E8%BD%AC%E8%87%B3%E9%AD%85%E6%97%8F%E6%89%8B%E6%9C%BA%E5%AE%98%E7%BD%91" target="_blank" rel="noopener">www.meizu.com，浏览器会自动跳转至魅族手机官网</a> <a href="http://m.meizu.com" target="_blank" rel="noopener">m.meizu.com</a>。这种跳转实现既可以由前端 JavaScript 完成，也可以通过后端返回 302 重定向来完成。</p><p>JavaScript 访问 <code>window.navigator.userAgent</code> 属性即可获取该信息。虽然该属性是只读的，但有很多前端手段可以伪造 UA 。如下图，Chrome 开发者工具在模拟不同的手机机型时，也会改变浏览器 UA 值。由此可见，通过检测 HTTP User-Agent Header 来识别是否为爬虫程序，不是一个有效的方法。</p><p><img src="https://cloud.githubusercontent.com/assets/344283/11623027/f2abc20c-9d04-11e5-9d57-95d5c1a90e46.png" alt="使用 Chrome 开发者工具模拟不同手机设备 UA"></p><p>在 PHP 中，所有的 HTTP Header 字段信息都保存在 <code>$_SERVER</code> 对象中，通过访问 <code>$_SERVER['HTTP_USER_AGENT']</code> 即可获取 User-Agent 的值。</p><h3 id="cookie用户身份标识">Cookie：用户身份标识</h3><hr><p>由于 HTTP 协议最初被设计成一种无状态的数据传输协议，服务器端无法判断每次处理的请求相互之间以及与之前处理的请求之间的关系，Cookie 的设计就是为了解决这个问题。</p><p>用户在浏览器中首次访问一个站点时，会通过请求响应头或页面JS脚本生成一些用于标识用户身份的 Cookie 信息，这些信息会按照域名分类，存放在浏览器本地缓存文件当中。例如 Windows 系统下通过访问 「C:\Users&lt;用户名&gt;\AppData\Local\Microsoft\Windows\Temporary Internet Files」 目录可以查看到 IE 浏览器保存在本地的 Cookie 文件。当用户再次访问该站点时，这些 Cookie 信息会被浏览器自动添加到 HTTP Request Header 的 Cookie 字段中，服务器通过读取这些信息，来区分当前请求的用户身份与状态。</p><p>浏览器可以通过读写 document.cookie 属性来添加或删除 Cookie 信息，服务器端可以通过 HTTP Response Header（响应头）中的 <strong>Set-Cookie</strong> 来改写客户端的 Cookie 信息。每一条 Cookie 属性通常都会设置一个过期时间，过期之后的 Cookie 浏览器将会自动清理它们，不会再被携带在 HTTP Request Header（请求头）中。</p><p>例如，以下 PHP 语句可以通过设置 Cookie 过期时间为前一个小时来触发客户端 Cookie 过期，达到删除 Cookie 的目的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setcookie(&apos;key&apos;, &apos;&apos;, time() - 3600, &apos;/&apos;);</span><br></pre></td></tr></table></figure><p>由于 Cookie 通常用于记录用户「帐号信息」和用户的「操作记录」，所以泄露 Cookie 会带来个人帐号与隐私泄露的风险。这也是为什么你在百度上搜索「贷款」的关键词之后，访问其他网站时就能看到相关的推荐广告，甚至第二天就会有各种放贷电话找上门来。</p><p>又由于 Cookie 可以随意被客户端修改（通过修改 document.cookie 属性），因此浏览器厂商们一起制定了 <a href="https://www.owasp.org/index.php/HttpOnly" target="_blank" rel="noopener">HttpOnly</a> 的 Cookie 机制。服务器端在 setcookie 时，通过设置 HttpOnly 的标识，可以防止客户端通过 JavaScript 修改 Cookie 的信息。不过这种方法对于基于 HTTP 协议进行篡改的方法来说无法防范，在之后的猫哥网络编程系列中，我将会介绍如何通过监控 Wi-Fi 流量来截取、伪造用户身份。</p><p>在 YSlow 性能优化最佳实践中，有两条与 Cookie 相关的建议：</p><ul><li><a href="https://developer.yahoo.com/performance/rules.html#cookie_size" target="_blank" rel="noopener">Reduce Cookie Size</a></li><li><a href="https://developer.yahoo.com/performance/rules.html#cookie_free" target="_blank" rel="noopener">Use Cookie-free Domains for Components</a></li></ul><p>虽然浏览器对 Cookie 的大小与数量有着较为严格的限制，但很多网站（尤其是包含登录态的）的 Cookie 信息量通常比其他所有 HTTP Header 加起来的还要多。为了减少不必要的 HTTP 数据传输量，YSlow 给出了以上两条优化建议。由于网页的静态资源（图片、CSS、JS）文件无需记录用户状态，因此通常会使用一个额外的域名（Cookie 是按域名来分类存储）来存放静态资源文件。</p><p>我们使用 Chrome 开发者工具查看「<a href="http://weibo.com/mgxqb" target="_blank" rel="noopener">猫哥学前班</a>」新浪微博主页，可以看到新浪微博使用了 <strong><a href="http://img.t.sinajs.cn" target="_blank" rel="noopener">img.t.sinajs.cn</a></strong> 的域名来存放它的 CSS 文件，这个域名发起的 HTTP Request Header 中没有自动带上 Cookie 字段信息 （因为前后端脚本都没有在这个域名上设置 Cookie，而是设置在了 <a href="http://weibo.com" target="_blank" rel="noopener">weibo.com</a> 域名上）：</p><p><img src="https://cloud.githubusercontent.com/assets/344283/11623043/16c19e50-9d05-11e5-9fb5-6bad3e37a416.png" alt="Use Cookie-free Domains"></p><p>这里还需要引申一个知识点：Session，它和 Cookie 有什么关系？由于 Session 与本文所讲的 HTTP 协议关系不大，相关知识点请自行百度。</p><h3 id="cache-control浏览器资源缓存标识">Cache-Control：浏览器资源缓存标识</h3><hr><p><strong>网站性能优化中，最为关键的是缓存机制（又是没有之一）</strong>。在服务器端通常会使用 Memcached、Redis 等服务来缓存经常访问的数据。例如在一个电商网站中，用户经常访问的热卖商品数据会被缓存在内存中，用户在一定时间内访问商品详情页时，后台程序直接从缓存服务中获取这段数据，这种方法可以大幅降低数据库的访问压力。</p><p>在用户端，浏览器会有一系列机制通过缓存来提升页面加载速度。例如 IE/Chrome 都会缓存 GET 类型的 AJAX 请求，IE 甚至会缓存 POST 类型的请求，需要通过增加时间戳参数的方式来强制清除缓存。对于所有的静态资源文件来说，最佳实践是为它们增加一个 「<a href="https://www.ietf.org/rfc/rfc2616.txt" target="_blank" rel="noopener">Never Expires</a>」（永不过期）的强（长）缓存，以下是一个强缓存静态资源服务器的 Nginx 配置示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name yekai.net;</span><br><span class="line">    root /var/www/yekai.net;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        index index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">    location ~ .*\.(gif|jpg|jpeg|png|bmp|swf|js|css)$ &#123;  </span><br><span class="line">        expires 365d;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过配置 「expires 365d」，HTTP Response Header（响应头）中会返回 「<strong>Cache-Control: max-age=31536000</strong>」 的头字段，配合 <strong>Last-Modified</strong> 头字段。浏览器便可以自动完成资源的强缓存。</p><p>Cache-Control 是浏览器缓存机制中最为重要的一个配置，以下是浏览器加载静态资源文件时的缓存检查机制流程：</p><p><img src="https://cloud.githubusercontent.com/assets/344283/11623053/278b3318-9d05-11e5-9515-8f76b53e6007.png" alt="浏览器缓存检查机制流程"></p><p>由此可见，静态资源缓存优化的最佳状态是：直接从本地缓存中读取 304 状态 200 状态。关于 HTTP 状态码，与网站性能优化有关的主要是以下几个。</p><ul><li>尽量减少 200 状态码的请求。200 表示是一个正常的请求返回，此条优化规则要求尽可能多的减少页面的 HTTP Request 数量。常见的方法有：合并打包静态资源、使用 CSS Sprite 雪碧图合并、缓存 AJAX、使用 LocalStorage/UserData/Manifest 等本地缓存技术。</li><li>清理返回 301/302 状态码的入口链接。301 表示永久重定向，302 表示临时重定向。服务器端使用重定向返回通常是为了兼容一个旧的入口链接。我们能做的优化是，将调用旧入口的场景进行清理，直接调用重定向之后的新 URL 地址。</li><li>304 表示静态资源未更新，浏览器可直接使用本地缓存文件。通常 304 的产生与浏览器的处理机制以及服务器缓存头配置有一定的关系。304 虽然未传输文件主体内容，但 HTTP 请求的建立依然是一个可以避免的性能损耗。腾讯 KM（内部知识分享平台）上有一篇文章通过在真实海量业务场景（没记错的话是 Qzone 业务）中，正交验证 HTTP 1.0 与 1.1 协议中与缓存相关的 HTTP Header 配置，结合日志分析得出了一个最佳实践：**关闭 <a href="http://baike.baidu.com/view/3039264.htm" target="_blank" rel="noopener">Etag</a> 配置，只启用 Cache-Control 与 Last-Modified 响应头。为了兼容老浏览器，可保留 Expires。**因为 Etag 的缓存方案，在经过 CDN 及网关代理服务器后，会导致缓存命中率下降。从以上「浏览器缓存检查机制流程」图上可以看出，使用强缓存（Cache-Control max-age 设置为一年）后浏览器在资源过期前不会发起 HTTP 请求，那如何保证静态资源在服务器上更新后本地的缓存也能同步更新呢？可参考百度 FIS 的「<a href="http://fis.baidu.com/fis3/docs/beginning/release.html#%E6%96%87%E4%BB%B6%E6%8C%87%E7%BA%B9" target="_blank" rel="noopener">文件指纹</a>」方案。</li><li>清理返回 404 状态码的入口链接。静态资源文件的 404 调用需严格避免，而入口页面的 404 则在所难免。通过在全站 404 页面进行产品引导与体验优化，并结合数据上报记录来源页（<a href="https://zh.wikipedia.org/wiki/HTTP%E5%8F%83%E7%85%A7%E4%BD%8D%E5%9D%80#.E6.8B.BC.E5.86.99.E9.97.AE.E9.A2.98" target="_blank" rel="noopener">HTTP Referer Header</a> 或 <code>document.referrer</code>），可以找到并清理 404 来源入口。对于由搜索引擎进入的来源，可通过主动提交新索引至搜索引擎，或使用 301/302 重定向的方式，有效利用起这些「被浪费的流量」。</li><li>502 服务器出错。如果是 Nginx + FastCGI 的常见架构，通常是由于 Nginx 缓冲区溢出或服务器资源被耗尽引起，针对不同的业务场景进行 Nginx 的配置优化能显著提升服务器抗压性能。</li></ul><p>如果你对上文提及的「网络性能优化」的知识点十分感兴趣，建议你通读 <a href="https://stevesouders.com/" target="_blank" rel="noopener">Steve Souders</a> 的《高性能网站建设指南》与《<a href="http://book.douban.com/subject/4719162/" target="_blank" rel="noopener">高性能网站建设进阶指南</a>》，Steve Souders 的个人网站上积累了很多性能优化的方法与案例。</p><p>如果你能看到这里，相信你已经知道明白关于 「<strong>HTTP 协议、状态码、缓存与性能优化</strong>」相关的问题。</p><h1 id="调试">调试</h1><hr><h2 id="http-pem-调试法之-proxy">「HTTP PEM 调试法」之 Proxy</h2><hr><p>Windows 下的 Fiddler 和 Mac 下的 Charles 这两款 HTTP 抓包工具，其实它们就是两个 HTTP 代理服务器（HTTP Proxy Server）。由于 HTTP 是一种符合 REST 架构风格（Representational State Transfer）的协议，具有无状态（Stateless）与统一接口（Uniform Interface）的架构约束，因此其代理机制的实现十分的简单。</p><p>打个比方，我们可以把 Proxy Server 理解成一个快递中转站，当一个包裹经过中转站时，包裹的信息（发件人、收件人与包裹里的货物）通常不会做任何的改动，直接发往下一个中转站或顾客手中。但中转站完全有能力修改快递单信息、拆箱检查货物，甚至是私吞或调换货物。</p><p>当我们需要快速定位「线上产品的接口问题」时，如果没有源码、数据、依赖服务和足够的时间去搭建一个测试环境，则通常会使用 HTTP 代理服务器来进行快速抓包调试。</p><p>Fiddler 默认只允许本地 IP（127.0.0.1）使用代理服务，通过设置「Tools -Connections -Allow remote computers to connect」可以开启其他 IP（通常是同一局域网内的其他设备）使用代理服务。</p><p><img src="https://cloud.githubusercontent.com/assets/344283/11863306/c3c93124-a4cd-11e5-9fef-e62a9f41d8f4.png" alt="Fiddler 开启 Remote Proxy"></p><p>Charles 默认开放代理服务，但陌生设备首次连接时需要授权确认，通过以下配置可以设置成无需授权。</p><p><img src="https://cloud.githubusercontent.com/assets/344283/11863310/d2da1c46-a4cd-11e5-8aec-a787c21982a1.png" alt="授权所有设备使用 Charles 代理服务"></p><p>以上两款软件默认的代理端口均是 <strong>8888</strong> ，软件开启之后，我们可以在对应的平台终端下通过 <code>ipconfig</code>（Windows） 或 <code>ifconfig</code>（Mac）命令查询本机的局域网 IP，还可以使用 <code>telnet</code> 命令检查代理通道是否可用。（注：Win7 下如何开启 telnet 命令请参考<a href="http://jingyan.baidu.com/article/95c9d20d96ba4aec4f756154.html" target="_blank" rel="noopener">百度经验</a>。）</p><p>以下是 Windows 下 CMD 终端的使用截图，Mac 系统下请类比参考。</p><p><img src="https://cloud.githubusercontent.com/assets/344283/11863316/e2acc09c-a4cd-11e5-931e-02d52c4cc849.png" alt="CMD 下 ipconfig 与 telnet"></p><p>接下来，我们将手机的 Wi-Fi 代理设置为上述的 IP 与 端口号，以下是 iOS 的设置截图（ Android 系统通常是长按已连接的 Wi-Fi ，在弹出的高级设置菜单中配置代理服务器）。</p><p><img src="https://cloud.githubusercontent.com/assets/344283/11863318/ec209d10-a4cd-11e5-94ce-a9634209c0f0.png" alt="iOS 下设置 HTTP 代理"></p><p>至此，手机上任意应用发起的 HTTP 请求都将会被代理服务器（本例中的 Fiddler/Charles 软件）监听到。</p><h2 id="http-pem-调试法之-edit">「HTTP PEM 调试法」之 Edit</h2><hr><p>通过代理服务器监听到 HTTP 请求之后，我们可以通过浏览报文的详细信息，定位出可能的接口问题。Fiddler 与 Charles 都具有同样强大的 HTTP 编辑（Edit）、重发（Replay/Repeat）、断点（Breakpoints）功能。Charles 的基础与高级用法请参考《<a href="http://blog.devtang.com/blog/2015/11/14/charles-introduction/" target="_blank" rel="noopener">Charles 从入门到精通</a>》，Fiddler 教程可以参考 OSChina 专题《<a href="http://www.oschina.net/p/fiddler" target="_blank" rel="noopener">HTTP调试代理 Fiddler</a>》，以下介绍 Fiddler 的部分常见用法。</p><h3 id="fiddler-edit-与-autoresponder">Fiddler Edit 与 AutoResponder</h3><hr><p>抓到手机 HTTP 请求之后，通过编辑（Unlock For Editing）和重发（Replay）操作可以不断地调试接口的响应是否符合预期。</p><p><img src="https://cloud.githubusercontent.com/assets/344283/11863324/fc243636-a4cd-11e5-99f5-01175fc23c14.png" alt="Fiddler 手动修改调试请求"></p><p>通过设置自动响应规则（AutoResponder Rules）可以将响应头设置成常见状态码的返回，或将响应体映射成本地文件，通过外部编辑器修改文件内容进行调试。其中，若设置响应为 <code>*bpu</code> 或 <code>*bpafter</code> 可以在请求前与响应前的事件触发时进行断点调试，十分方便。</p><p><img src="https://cloud.githubusercontent.com/assets/344283/11863326/047d1708-a4ce-11e5-87d6-70c3a49e513f.png" alt="Fiddler 将请求映射本地文件"></p><p>需要注意的是，在 Fiddler 中使用 Replay 功能重发请求时，请求由 Fiddler 代理重新发起而非手机，因此手机 App 中的 H5 不会有任何变化。只有重新刷新 App 的 H5 页面，配合 HTTP 断点调试（Breakpoints ）的方式才可以让修改后的 HTTP 响应体在 App中生效。这里介绍另外一种配合 <a href="https://people.apache.org/~pmuellr/weinre-docs/latest/" target="_blank" rel="noopener">Weinre</a> 的调试用法。</p><h3 id="weinre-基本用法">Weinre 基本用法</h3><hr><p>Weinre 属于知名 Hybrid 框架 <a href="https://cordova.apache.org/" target="_blank" rel="noopener">Cordova</a> 中的一款 Web App 远程调试工具。通过在页面中注入一段 JS 脚本，可以在 PC 和手机端的 H5 页面之间建立一个 Socket 双向数据传输通道。原理上可以理解为，当我们在 PC 端的后台进行 debug 时，相关的操作被序列化成一组 JSON 字符串，数据经由通道传输给手机端中的 H5 页面，页面在接收到这些数据之后反序列化成相应的 JS 脚本操作，在其 window 上下文中执行，并将执行的结果回传给通道，PC 端的 Chrome 通过监听通道获取到相应的数据在 debug 后台中展现出来。</p><p>以下介绍 Weinre 的基本用法：</p><ol><li>通过 <a href="https://nodejs.org/" target="_blank" rel="noopener">npm</a> 全局安装 weinre： <code>npm install -g weinre</code></li><li>在本地 8081 端口上启动 weinre 服务：<code>weinre --boundHost 0.0.0.0 --httpPort 8081</code> 。通常在 Node.js 的服务中绑定 IP 为 0.0.0.0 而非 127.0.0.1（本地 IP），意味着可以让任意来源的 IP 访问该服务</li><li>通过上文介绍的 <code>ipconfig</code>（Mac 为 <code>ifconfig</code>）命令获取本机 IP 后，在本机 Chrome 浏览器中访问 Weinre 管理后台：<a href="http://10.2.69.47:8081" target="_blank" rel="noopener">http://10.2.69.47:8081</a> （本例中我的 IP 为 10.2.69.47，请注意将其替换成自己的局域网 IP）</li><li>在管理后台我们能看到相关使用说明，要求将以下脚本插入需要调试的 H5 页面中：<code>&lt;script src=&quot;http://10.2.69.47:8081/target/target-script-min.js#anonymous&quot;&gt;&lt;/script&gt;</code></li><li>将以上脚本插入进 H5 页面后，我们在 PC 端 Chrome 中，通过 <strong><a href="http://10.2.69.47:8081/client/#anonymous" target="_blank" rel="noopener">http://10.2.69.47:8081/client/#anonymous</a></strong> 后台点击进入相应的客户端调试界面</li></ol><p>问题是，我们「<strong>如何将 Weinre Script 自动注入到手机的 H5 页面中</strong>」？</p><h3 id="http-script-注入">HTTP Script 注入</h3><hr><p>想必用过中国电信宽带的同学都有过这样的体验：在刚开始浏览网页时，会自动跳出一些「宽带升级优惠」、「宽带缴费提醒」之类的页面。这种耍流氓的方式便是宽带运营商在 HTTP 代理层面的 Script 注入行为。前面已经提到 HTTP 协议是一种 REST 风格的架构，并且他的头部与主体报文为字符串文本流（对比二机制、十六进制数据流），在不使用 HTTPS 的情况下，很容易被中间路由或代理网关进行消息篡改。</p><p>通过 Fiddler Script 特性，我们可以自动对经过 Fiddler 的 HTTP 流量进行二次修改，注入任意内容（Mac 用户若已了解相关知识点，请直接跳至下方的 Charles 截图）。</p><p>打开 Fiddler 菜单「Rules -Customize Rules… 」，如果是首次开启会要求先下载安装 Fiddler ScriptEditor。打开 Fiddler ScriptEditor 之后，找到以下代码块（或使用菜单「Go -to OnBeforeResponse」）：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">OnBeforeResponse</span>(<span class="params">oSession: Session</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_Hide304s &amp;&amp; oSession.responseCode == <span class="number">304</span>) &#123;</span><br><span class="line">        oSession[<span class="string">"ui-hide"</span>] = <span class="string">"true"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://docs.telerik.com/fiddler/KnowledgeBase/FiddlerScript/ModifyRequestOrResponse" target="_blank" rel="noopener">Fiddler Script</a> 使用的编程语言是 <a href="http://JScript.NET" target="_blank" rel="noopener">JScript.NET</a>（JavaScript 和 C# 的混合语法，类似 TypeScript），<code>OnBeforeResponse</code> 是 HTTP Response 响应前的事件函数，我们只需要在这里判断「如果开启了 Weinre Debug 功能，那么就在所有的 HTML 响应体中注入 Weinre Script」，以下是我修改的示例代码，覆盖以上代码块即可。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> RulesOption(<span class="string">"Enable Weinre Script"</span>)</span><br><span class="line"><span class="keyword">var</span> m_EnableWeinreScript: <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> g_weinreScriptString: <span class="built_in">String</span> = <span class="string">'&lt;script src="http://127.0.0.1:8080/target/target-script-min.js#anonymous"&gt;&lt;/script&gt;'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ToolsAction(<span class="string">"Config Weinre Script"</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ConfigWeinreScript</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    g_weinreScriptString = FiddlerObject.prompt(<span class="string">"Text beblow will inject into HTML pages when 'Enable Weinre Script' rule is Enabled."</span>, g_weinreScriptString , <span class="string">"Please Input the Weinre Script"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">OnBeforeResponse</span>(<span class="params">oSession: Session</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m_Hide304s &amp;&amp; oSession.responseCode == <span class="number">304</span>) &#123;</span><br><span class="line">        oSession[<span class="string">"ui-hide"</span>] = <span class="string">"true"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m_EnableWeinreScript &amp;&amp; oSession.oResponse.headers.ExistsAndContains(<span class="string">"Content-Type"</span>,<span class="string">"text/html"</span>))&#123;</span><br><span class="line">        oSession.utilDecodeResponse();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(oSession.utilFindInResponse(<span class="string">"&lt;/html&gt;"</span>, <span class="literal">false</span>)&gt;<span class="number">-1</span>)&#123;</span><br><span class="line">            oSession[<span class="string">"ui-backcolor"</span>] = <span class="string">"#5E30B5"</span>;</span><br><span class="line">            oSession[<span class="string">"ui-color"</span>] = <span class="string">"white"</span>;</span><br><span class="line">            oSession.utilReplaceRegexInResponse(<span class="string">"&lt;\/html&gt;"</span>, g_weinreScriptString + <span class="string">'&lt;/html&gt;'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改保存后重启 Fiddler（或使用菜单「Tools -Reset Script」）以生效规则，接下来运行「Tools」菜单中新出现的「Config Weinre Script」，将 <strong>127.0.0.1:8080</strong> 替换成自己本机的局域网 IP 与 weinre 服务端口号，同时开启菜单「Rules -Enable Weinre Script」。至此，所有 HTML 页面将会被自动注入 Weinre Script，之后我们就可以在 weinre 后台中开始调试相关页面。以下是参考截图：</p><p><img src="https://cloud.githubusercontent.com/assets/344283/11863336/14c5227c-a4ce-11e5-8cc8-bffd4842c115.png" alt="Fiddler 中的 HTTP Script 注入"></p><p>可以看到 HTTP 响应体中已经被动态注入 Weinre Script。</p><p>在 Mac Charles 下的 Script 注入配置更加容易，只需利用其 「Rewrite」功能进行简单的配置即可，参看下图：</p><p><img src="https://cloud.githubusercontent.com/assets/344283/11863339/220a5a88-a4ce-11e5-801c-3c5eb86ed3c9.png" alt="Charles Rewrite 配置 HTTP Script 注入"></p><p>通过 Fiddler/Charles 代理工具将 JS 脚本注入成功后，我们便可以通过前文提到的 weinre 后台开始 debug 相应的页面，以下是在 iPhone 模拟器中调试新浪微博界面的截图：</p><p><img src="https://cloud.githubusercontent.com/assets/344283/11863348/2c3bdbbc-a4ce-11e5-9329-816fd0ff6454.png" alt="Weinre 后台 debug Webview H5 页面"></p><p>使用该方法可以调试 Android 和 iOS 中「<strong>任意 App 的 H5 页面</strong>」，但由于主要使用了 weinre 服务，其原理决定了该方法无法像真正的 Chrome DevTools 一样支持 JS 断点调试、Profiles 性能分析等功能，具有一定的局限性。在实际 Web App 开发过程中，推荐使用以下工具进行调试 ：</p><ul><li><a href="http://blog.qqbrowser.cc/" target="_blank" rel="noopener">微信官方调试工具</a> 调试基于微信的 Web App</li><li><a href="https://developer.chrome.com/devtools/docs/remote-debugging" target="_blank" rel="noopener">Chrome Remote Debugging</a> 调试 Android Web App</li><li><a href="http://developer.telerik.com/featured/a-concise-guide-to-remote-debugging-on-ios-android-and-windows-phone/" target="_blank" rel="noopener">Safari Remote Debugging</a> 调试 iOS Web App</li></ul><p>由此可见，「HTTP PEM 调试法」是一个通用的 HTTP 接口调试方案，可以用来快速定位线上接口问题，对于开发人员来说掌握其背后的 HTTP 协议及其代理机制的原理更加重要，接下来我们聊聊常见的 HTTP 接口开发协作方法与 Mock 思路。</p><p>我的开发任务没法推进，因为某某的接口还没提供给我。</p><h2 id="http-pem-调试法之-mock">「HTTP PEM 调试法」之 Mock</h2><hr><p>希望新手程序员在看完这一章节之后，不要再向你的项目组和上级反馈这样的说法，因为 HTTP Mock（接口数据模拟）是一项网络编程的基础技能，从实际项目经验来看，大部分基于 HTTP 接口的任务都可以并行开发。</p><h3 id="最简-http-api">最简 HTTP API</h3><hr><p>不同岗位（例如前端开发与后台开发）或不同业务（例如订单系统与账户系统）的开发人员开始并行开发任务之前，首先要做的应该是对耦合和相互依赖的任务进行边界划分与规则约定。具体到某个 HTTP API 接口的约定上，至少应该明确以下信息：</p><ol><li>是否按照 <a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="noopener">RESTful API</a> 的约定来设计接口</li><li>接口的路径、提交方法、参数、编码类型（Enctype/Content-Type）</li><li>接口返回的错误码（code）、消息说明（message）、业务数据（data）</li></ol><p>针对以上三条信息，我设想的「最简」 HTTP API 包含以下几条原则，供各位参考：</p><h4 id="1-不使用-restful-api-来设计接口">1、不使用 RESTful API 来设计接口</h4><hr><p>RESTful API 实际上是利用 HTTP 协议的语义（提交类型、返回码、<a href="https://developer.github.com/v3/#hypermedia" target="_blank" rel="noopener">Hypermedia Link</a>）来将所有接口操作抽象化为一系列资源对象。这要求 API 的设计者与调用者都具备深厚的 HTTP 协议功底、语义化与抽象化能力。</p><ul><li>RESTful 作为一个 Buzzword（流行词），其含义已经被曲解。HTTP 协议和 REST 架构的设计者 Roy Fielding 很反感这一点，还专门开了<a href="http://roy.gbiv.com/untangled/2008/no-rest-in-cmis" target="_blank" rel="noopener">博客以正视听</a>。大多数人只将 <a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/evaluation.htm#sec_6_5_3" target="_blank" rel="noopener">HTTP 当做一种传输协议</a>来使用（既成事实），并不能真正理解  REST 架构风格；</li><li>RESTful API 将所有请求抽象化为资源名词（Resources）的做法争议很大。这种做法总会让我回想起上个世纪用 FrontPage 做网页的经历，「设置一个超链接，从某个资源跳到另外一个资源」。在经过 Web 2.0 浪潮，进入移动互联网时代后，这种 API 设计容易给人带来困惑。例如「登录、注册」这样的「动词」如何抽象成「名词」（还好有 <a href="https://developer.github.com/v3/oauth/" target="_blank" rel="noopener">Github API</a> 可以参考 ）。而刻意的使用 「HTTP CRUD」（POST/GET/PUT/DELETE Method）操作「资源化」之后的接口，并未带来更多实质上的收益；</li><li>HTTP 状态码的分层思路在 RESTful API 模式下被破坏了。<a href="http://www.restapitutorial.com/httpstatuscodes.html" target="_blank" rel="noopener">HTTP 1.0 中定义的常见状态码</a>已经足够网络中间组件（代理、网关、路由）使用，HTTP 1.1 中加入的很多状态码缺乏实际场景（例如 <a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes" target="_blank" rel="noopener">306 状态码的废弃</a>），它们增加了中间组件以及浏览器对规范理解与实现的要求。尽可能的将状态码交给相应的接口逻辑层而非 HTTP 协议层，能够将问题简化；</li><li>对比以英文为母语的国外开发者而言，国内开发者对语义化的认知难度更高，例如 RESTful 建议<strong>资源命名用复数形式</strong>，那收货地址单词 address 的复数形式是什么？address or addresses ？address-list or address-lists？（没过英语八级的同学已经哭晕在厕所 T_T）</li><li>每个人对 RESTful API 的理解都不同，在 HTTP 协议层面做扩展与实现，不如交给接口设计者与调用者自己来约定数据结构（或者参考 <a href="http://wiki.geekdream.com/Specification/json-rpc_2.0.html" target="_blank" rel="noopener">JSON-RPC</a> 规范）。把 HTTP 只当做传输协议来使用的好处是，当后端服务间的接口需要直接基于 TCP 传输层来做性能优化时，可以十分方便的切换成 Socket 的实现（之前在腾讯做微博相关项目时，微博开放平台对外只提供 HTTP 的 Open API，但对内可以提供更高频率与频次调用的原生 Socket 协议）。</li></ul><h4 id="2-只使用-getpost-method">2、只使用 GET/POST Method</h4><hr><p>由于 HTTP 1.0 尤其是 HTML 的规范与应用已经深入人心。大部分开发者能够很自然的这样理解：「GET」 表示「读」操作，「POST」 表示「写」操作。这样既可以保证中间组件与浏览器很好的利用 GET 的缓存机制，又能降低接口设计的复杂度。HTTP 之父 Roy Fielding 也说过「<a href="http://roy.gbiv.com/untangled/2009/it-is-okay-to-use-post" target="_blank" rel="noopener">It is okay to use POST</a>」：</p><p>Some people think that REST suggests not to use POST for updates. Search my dissertation and you won’t find any mention of CRUD or POST. （很多人认为 RESTful 建议不要使用 POST 用于提交更新，去翻一翻我的论文，压根就没提到过 POST 和其他「增查改删」方面的内容。）</p><p>但使用 POST 方法时尤其要注意：「使用统一的 Content-Type」。这是一个容易被新手忽略的细节，也是接口设计中经常出错的点。</p><p>一个 POST 请求的 Content-Type 有多少种，传输的数据格式有何区别？</p><p>以下举例一些常见类型的 HTTP POST Request 报文，请注意其中的 <code>Content-Type</code> 与 Body 的对应关系（已手动删除无关 HTTP Header）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /test.php HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:8080</span><br><span class="line">Content-Length: 54</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;&quot;weixin_id&quot;:&quot;imgXQB&quot;,&quot;weixin_name&quot;:&quot;学前班&quot;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /test.php HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:8080</span><br><span class="line">Content-Length: 74</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">weixin_id=imgXQB&amp;weixin_name=%E7%8C%AB%E5%93%A5%E5%AD%A6%E5%89%8D%E7%8F%AD</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST /test.php HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:8080</span><br><span class="line">Content-Length: 259</span><br><span class="line">Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryl60ti7CVoBj2kxfX</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundaryl60ti7CVoBj2kxfX</span><br><span class="line">Content-Disposition: form-data; name=&quot;weixin_id&quot;</span><br><span class="line"></span><br><span class="line">imgXQB</span><br><span class="line">------WebKitFormBoundaryl60ti7CVoBj2kxfX</span><br><span class="line">Content-Disposition: form-data; name=&quot;weixin_name&quot;</span><br><span class="line"></span><br><span class="line">学前班</span><br><span class="line">------WebKitFormBoundaryl60ti7CVoBj2kxfX--</span><br></pre></td></tr></table></figure><p>只有客户端 POST 请求体的消息格式与其请求头声明的 <strong>Content-Type</strong> 一致时，服务端才能正确的接收与响应。因为许多后端的 Web 应用框架会遵照 HTTP 协议的内容协商原则（<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec12.html" target="_blank" rel="noopener">Content Negotiation</a>）对响应体进行预处理，以提升开发体验。例如，Python 的 <a href="http://flask.pocoo.org/docs/0.10/api/#incoming-request-data" target="_blank" rel="noopener">Flask 框架</a> 封装了 <strong>request.json</strong>、<strong>request.form</strong>、<strong>request.data</strong> 等一系列属性用于存放不同类型的来源数据。</p><h4 id="3-接口-uri-与参数命名风格的一致性">3、接口 URI 与参数命名风格的一致性</h4><hr><ul><li>API URI 应该全小写。屏蔽掉 Linux/Windows 操作系统对文件名大小写敏感度不一致的问题；</li><li>URI 命名上应该使用连字符「-」来间隔，而不是使用下划线「_」或驼峰式。这是出于视觉美观度和英文语义方面的考虑，英文域名规范规定可以使用连字符，但不能使用下划线，API 路径应该和 Domain 命名风格一致；</li><li>URI 使用「动词+名词」或者「名词+动词」均可，但选定一种之后应该保持一致。接口风格的一致性，可以降低使用者的理解成本，好的 API 命名风格能让人「以一知万」，能从一个 API 猜测出所有其他 API 的命名形式；</li><li>参数命名上应该使用下划线「_」而非连接符「-」。这点主要是从数据库字段设计的统一性和后台应用程序框架的易用性来考虑；</li><li>不同接口的相同参数命名应保持统一，并考虑扩展要求。例如，收集用户信息的参数可以统一叫「ua」，为了便于扩展可以约定将客户端分辨率、浏览器型号等信息使用「||」字符串连接，如 <code>ua=1280x768||chrome</code>，当需要添加操作系统字段时，客户端只需按规则追加信息到原来的参数上，如 <code>ua=1280x768||chrome||windows</code>。该条原则还有许多其他的方法来实现，不再一一举例。</li></ul><h4 id="4-返回数据结构的一致性">4、返回数据结构的一致性</h4><hr><p>基本的返回体结构，可参考以下示例代码。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"code"</span>: <span class="string">"0"</span>,</span><br><span class="line">    <span class="attr">"message"</span>: <span class="string">"success"</span>,</span><br><span class="line">    <span class="attr">"data"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span> : <span class="string">"1"</span>,</span><br><span class="line">        <span class="attr">"list"</span> : []</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>寥寥的几行代码饱含了几部深刻的血泪史：</p><ul><li>出于一致性的考虑，<code>code</code> 表示返回码（也可以理解成错误码），成功时返回 <code>&quot;0&quot;</code> ，出错时按预设的错误码规则返回（<a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419318634&amp;token=&amp;lang=zh_CN" target="_blank" rel="noopener">微信的返回码规范</a>设计的并不好，因为没有内建的规律和语义）；</li><li>同上，可以理解 <code>message</code> 与 <code>data</code> 的设计。需要注意的是 <strong>data</strong> 只具有 <strong>Object</strong> 一种类型。无数据的时候返回一个空对象 <code>{}</code>（而非 <code>null</code>），有多条数据的时候将  <strong>Array</strong> 类型数据放在其内部的 <code>list</code> 之类的属性中；</li><li>所有原始数据类型建议统一使用字符串类型，包括布尔值用 <code>&quot;0&quot;</code> 和 <code>&quot;1&quot;</code>。原因是前后端对浮点数运算精度不一致，会导致商品价格的计算与展示出错；iOS/Android 客户端对 JSON null、布尔类型转换的不一致会导致频繁的 App Crash。</li></ul><p>当然，也有许多其他的方案可以解决上面提到的问题，但出于「最简」的原则，这样约定的理解成本最低。</p><h3 id="最简-mock-server">最简 Mock Server</h3><hr><p>有了最简 API 的约定之后，实现最简 Mock Server 就相对简单多了。</p><h4 id="1-编写返回的模拟数据">1、编写返回的模拟数据</h4><hr><p>首先，我们按照 API 接口约定来新建一些模拟数据文件。例如新建一个 「mock-data.json」 的文件，将以上返回体数据保存其中。</p><h4 id="2-运行-php-内置服务器">2、运行 php 内置服务器</h4><hr><p>在命令行模式下运行 <code>php</code> 命令，Mac 用户直接打开终端即可，Windows 用户需要先安装 <a href="https://www.apachefriends.org/index.html" target="_blank" rel="noopener">XAMPP</a> 套件，并将 php.exe 所在的目录<a href="https://github.com/kaiye/kaiye.github.com/issues/2" target="_blank" rel="noopener">配置到系统环境变量</a>中，再使用 CMD 运行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php -S 0.0.0.0:8080 mock-data.json</span><br></pre></td></tr></table></figure><p>开启之后访问任意 API 地址（<a href="http://127.0.0.1:8080/any-api-uri-you-want/%EF%BC%89%E5%9D%87%E4%BC%9A%E8%BF%94%E5%9B%9E" target="_blank" rel="noopener">http://127.0.0.1:8080/any-api-uri-you-want/）均会返回</a> mock-data.json 的数据响应体。通过将 8080 端口换成 80 端口（Mac 需要使用 sudo 权限），再设置类似 <code>127.0.0.1 www.example.com</code> 的 HOST 配置，便可以模拟 API 的 Domain Host（<a href="http://www.example.com/any-api-uri-you-want/%EF%BC%89%E5%BD%A2%E5%BC%8F%E3%80%82" target="_blank" rel="noopener">http://www.example.com/any-api-uri-you-want/）形式。</a></p><p>当然，也可以自己编写一个 index.php 的入口文件来实现一个基于 URL Path 规则的简单 Rewrite 功能，用来同时支持多个 API 的数据模拟。</p><h3 id="使用-fiddlercharles-的-map-local-功能">使用 Fiddler/Charles 的 Map Local 功能</h3><hr><p>Fiddler/Charles 的 Map Local（本地映射）不光是用于 HTTP Edit，同样可以用于 HTTP Mock，当一个 404 请求（还未真正实现的 API）被代理服务器捕获后，可以设置映射到本地自定义的 mock-data.json 模拟数据文件，从而被模拟成一个正常的 200 请求。</p><h3 id="自动化-mock-system-构想">自动化 Mock System 构想</h3><hr><p>迄今为止，我还未发现一个理想中的 Mock API 开源系统，如有哪位同学有见到过请在 Github 上留言周知，以下是我对最理想 Mock System 的构想：</p><ol><li>API 录入后台。包含一个按项目（一般是 Domain）维度进行 API 管理的后台。可以在后台上录入「请求 URI、参数、多种业务数据响应体、全局错误码、API 错误码」等接口信息；</li><li>API 接口文档。能够基于 API 后台数据，生成在线的 API 文档平台；</li><li>Postman 导入/导出。能够基于 API 数据导出生成 <a href="https://www.getpostman.com/docs/collections" target="_blank" rel="noopener">Postman Collections</a>，以便导入 Postman 中进行 API 调试；</li><li>Mock Server。能够基于 API 数据快速搭建类似 <a href="http://www.mock-server.com/mock_server/" target="_blank" rel="noopener">MockServer</a> 的本地服务，或提供远程模拟接口服务。</li></ol><h2 id="http-pem系统分析利器">「HTTP PEM」系统分析利器</h2><hr><p>这个接口很复杂，内部调用了好几个其他接口，如何定位问题究竟出在哪一步？</p><p>对于新人来说，最快的成长方式是不断地在新项目中实践，从头到尾参与到项目的每个系统细节的设计与讨论。如果能参与到重点、大型项目中，甚至幸运地得到大牛的亲自指导，成长速度将会突飞猛进。</p><p>但更多的情况是，新人作为离职程序员的补充力量来接手一个老项目甚至是烂摊子。面对一个复杂的陌生系统，吐槽与抱怨无济于事。这时，如果能使用「HTTP PEM 调试法」，从接口设计与调用的角度来剖析、理解整个系统的设计，就能快速上手业务。例如，PHP 程序员可以在项目代码中所有的 curl 调用点，将「<a href="http://php.net/manual/zh/function.curl-setopt.php" target="_blank" rel="noopener">CURLOPT_PROXY</a>」设置成 Fiddler/Charles 的代理服务，然后一步步调试，从接口字段上理解数据库设计和 Controller 背后的业务逻辑。</p><p>最后，欢迎各位给我留言分享更多关于「HTTP PEM」和其他调试方法的经验与体会。</p><hr><p>Reference：</p><blockquote><p>GitHub Repo：<a href="https://github.com/CoderTonyChan/CoderTonyChan.github.io" target="_blank" rel="noopener">Tony Studio</a></p><p>Follow: <a href="https://github.com/CoderTonyChan" target="_blank" rel="noopener">CoderTonyCHan · GitHub</a></p></blockquote>]]></content:encoded>
      
      <comments>https://blog.tonystudio.ml/2016/09/18/HTTPS-Charles/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Git/GitHub操作指南</title>
      <link>https://blog.tonystudio.ml/2016/02/18/git-collect/</link>
      <guid>https://blog.tonystudio.ml/2016/02/18/git-collect/</guid>
      <pubDate>Thu, 18 Feb 2016 02:51:24 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;Git 是程序员必备技能，在能熟练使用 Git GUI 客户端之后（如 SoureTree、Github Desktop，或者是 VSCode 的 git 面板或 GitLens 插件），也许你希望能了解到更多关于 Git 的知识点，并用于解决实际
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>Git 是程序员必备技能，在能熟练使用 Git GUI 客户端之后（如 SoureTree、Github Desktop，或者是 VSCode 的 git 面板或 GitLens 插件），也许你希望能了解到更多关于 Git 的知识点，并用于解决实际项目遇到的问题。</p></blockquote><p><img src="http://pn9jzw2t9.bkt.clouddn.com/2019/git.1.jpg" alt=""></p><h1 id="git删除所有历史提交记录">git删除所有历史提交记录</h1><hr><p>把旧项目提交到Git上，但是会有一些历史记录，这些历史记录中可能会有项目密码等敏感信息。如何删除这些历史记录，形成一个全新的仓库，并且保持代码不变呢？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1. Checkout</span><br><span class="line"></span><br><span class="line">   git checkout --orphan latest_branch</span><br><span class="line"></span><br><span class="line">2. Add all the files</span><br><span class="line"></span><br><span class="line">   git add -A</span><br><span class="line"></span><br><span class="line">3. Commit the changes</span><br><span class="line"></span><br><span class="line">   git commit -am "commit message"</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4. Delete the branch</span><br><span class="line"></span><br><span class="line">   git branch -D master</span><br><span class="line"></span><br><span class="line">5.Rename the current branch to master</span><br><span class="line"></span><br><span class="line">   git branch -m master</span><br><span class="line"></span><br><span class="line">6.Finally, force update your repository</span><br><span class="line"></span><br><span class="line">   git push -f origin master</span><br></pre></td></tr></table></figure><h1 id="git多个远程仓库">git多个远程仓库</h1><hr><blockquote><p>用GitHub管理自己的开源项目有几年了,有时候需要同步GitHub和公司的Gitlab</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">        repositoryformatversion = 0</span><br><span class="line">        filemode = true</span><br><span class="line">        bare = false</span><br><span class="line">        logallrefupdates = true</span><br><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">        url = https://github.com/CoderTonyChan/laoshihao-login-web</span><br><span class="line">        fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch &quot;master&quot;]</span><br><span class="line">        remote = origin</span><br><span class="line">        merge = refs/heads/master</span><br></pre></td></tr></table></figure><h2 id="用git命令行添加多个远程仓库">用git命令行添加多个远程仓库</h2><p>添加一个名为“mirror”的远程仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add mirror https://gitee.com/CoderTonyChan/laoshihao-login-web.git</span><br></pre></td></tr></table></figure><p>执行完这条命令后.git/config文件内容变成了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">        repositoryformatversion = 0</span><br><span class="line">        filemode = true</span><br><span class="line">        bare = false</span><br><span class="line">        logallrefupdates = true</span><br><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">        url = https://github.com/CoderTonyChan/laoshihao-login-web</span><br><span class="line">        fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch &quot;master&quot;]</span><br><span class="line">        remote = origin</span><br><span class="line">        merge = refs/heads/master</span><br><span class="line">[remote &quot;mirror&quot;]</span><br><span class="line">        url = https://gitee.com/CoderTonyChan/laoshihao-login-web.git</span><br><span class="line">        fetch = +refs/heads/*:refs/remotes/mirror/*</span><br></pre></td></tr></table></figure><p>此时已经是一个本地仓库，两个远程仓库。使用下面的命令可以分别从两个远程仓库拉取和推送到两个远程仓库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master </span><br><span class="line">git pull mirror master</span><br><span class="line">git push origin master </span><br><span class="line">git push mirror master</span><br></pre></td></tr></table></figure><h2 id="一条命令同时更新多个远程仓库">一条命令同时更新多个远程仓库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url --add origin https://gitee.com/CoderTonyChan/laoshihao-login-web.git</span><br></pre></td></tr></table></figure><p>执行这条命令后.git/config内容变成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">        repositoryformatversion = 0</span><br><span class="line">        filemode = true</span><br><span class="line">        bare = false</span><br><span class="line">        logallrefupdates = true</span><br><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">        url = https://github.com/CoderTonyChan/laoshihao-login-web.git</span><br><span class="line">        url = https://gitee.com/CoderTonyChan/laoshihao-login-web.git</span><br><span class="line">        fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch &quot;master&quot;]</span><br><span class="line">        remote = origin</span><br><span class="line">        merge = refs/heads/master</span><br></pre></td></tr></table></figure><p>这时候我们一条命令即可更新两个远程仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><h1 id="github-release功能">Github Release功能</h1><hr><p><img src="https://user-images.githubusercontent.com/16996753/54014341-41c8a580-41b7-11e9-9315-fcd79768826b.png" alt="image"></p><h2 id="tag">Tag</h2><hr><p>填写这个代表用最新的代码打包📦</p><p>否则是用存在的Tag修改</p><h2 id="release-note">Release Note</h2><hr><p>使用md语法</p><h2 id="二进制文件上传">二进制文件上传</h2><hr><p>可以上传编译好的二进制文件</p><h2 id="this-is-a-pre-release">This is a pre-release</h2><hr><p>钩上证明还在测试</p><p><img src="https://user-images.githubusercontent.com/16996753/54014528-05497980-41b8-11e9-8d92-b33608a2b591.png" alt="image"></p><p>钩上GitHub有标志</p><h2 id="规范">规范</h2><hr><p>建议使用这个规范</p><p>tag表明是否beta版本</p><p>v1.0%beta2</p><p>标题使用</p><p>v1.0 pre-release</p><h1 id="github-实用功能">Github 实用功能</h1><hr><p>一些常用功能</p><h2 id="粘贴图片">粘贴图片</h2><hr><p>Ctrl+C</p><h2 id="链接到代码">链接到代码</h2><hr><p>打开一个文件，点击代码左边的行号，或者按住 shift 选择多行。</p><p>分享这个 URL ，可以链接到这些代码。如果文件被修改了，会发生变化吗?不会，因为这是永久链接。</p><p><img src="https://user-images.githubusercontent.com/16996753/54014907-1941ab00-41b9-11e9-95b5-d0876529ef5a.png" alt="image"></p><h2 id="创建复选框列表">创建复选框列表</h2><hr><p>“2/5” 的进度条</p><p><img src="https://user-images.githubusercontent.com/16996753/54014991-573ecf00-41b9-11e9-91f6-1daa82016fe3.png" alt="image"></p><p>交互式复选框语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- [ ] Screen width (integer) </span><br><span class="line">- [x] Service worker support </span><br><span class="line">- [x] Fetch support </span><br><span class="line">- [ ] CSS flexbox support </span><br><span class="line">- [ ] Custom elements</span><br></pre></td></tr></table></figure><p>⚠️注意: 这是GitHub支持 并不是md语法</p><h2 id="github-wiki">GitHub wiki</h2><hr><p>非结构化网页 可用于文档</p><h2 id="github作为cms内容管理系统">GitHub作为CMS(内容管理系统)</h2><hr><p>文本写在 markdown 文件中，然后存到你的仓库。接着在前端写一个组件来请求文件然后渲染。</p><p>marked( <a href="https://www.npmjs.com/package/marked" target="_blank" rel="noopener">https://www.npmjs.com/package/marked</a> ) 插件来解析markdown</p><h2 id="快速引用">快速引用</h2><hr><p>你可以选中别人的评论文字，然后按r，这些内容会以引用的形式被复制在文本框中：</p><hr><p>Reference：</p><blockquote><p>GitHub Repo：<a href="https://github.com/CoderTonyChan/CoderTonyChan.github.io" target="_blank" rel="noopener">Tony Studio</a></p><p>Follow: <a href="https://github.com/CoderTonyChan" target="_blank" rel="noopener">CoderTonyCHan · GitHub</a></p></blockquote>]]></content:encoded>
      
      <comments>https://blog.tonystudio.ml/2016/02/18/git-collect/#disqus_thread</comments>
    </item>
    
    <item>
      <title>WWDC 2015 Xcode 7</title>
      <link>https://blog.tonystudio.ml/2015/06/12/Xcode-appid/</link>
      <guid>https://blog.tonystudio.ml/2015/06/12/Xcode-appid/</guid>
      <pubDate>Thu, 11 Jun 2015 16:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;从Xcode7开始,Xcode 不需要$99/$299升级开发者直接可以进行真机调试。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;xcode-7&quot;&gt;Xcode 7&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;WWDC 15最大惊喜.&lt;/p&gt;
&lt;h2 id=
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>从Xcode7开始,Xcode 不需要$99/$299升级开发者直接可以进行真机调试。</p></blockquote><h1 id="xcode-7">Xcode 7</h1><hr><p>WWDC 15最大惊喜.</p><h2 id="0x1">0x1</h2><p>假设已经你已经有了苹果账号,下载并安装好了Xcode7</p><h2 id="0x2">0x2</h2><p>打开Xcode-&gt; Preferences -&gt;Accounts  点加号增加一个Apple ID</p><h2 id="0x3">0x3</h2><p>添加后发现 多了一行以Apple ID 账号名称为名称的Team,我的是 fox sky,如图所示,iOS/Mac 都显示成了free</p><p><img src="https://user-images.githubusercontent.com/16996753/53939872-3b6ef680-40ef-11e9-8d8e-a8c71dcf58bf.png" alt="image"></p><h2 id="0x4">0x4</h2><p>双击Team name,弹出下图,增加 iOS Development 与 Mac Developement证书,底部显示的是所有已经生成的Provisioning Profile文件,目前为空</p><p><img src="https://user-images.githubusercontent.com/16996753/53939895-49247c00-40ef-11e9-9c42-386a8bc967f8.png" alt="image"></p><h2 id="0x5">0x5</h2><p>返回target,选择刚刚的Team 名称(Apple ID名称),点击fix issue 自动生产Provisioning Profile文件,Provisioning Profile文件可以在步骤四中的底部列表查看</p><h1 id="注意事项">注意事项</h1><hr><p>Bundle ID (Bundle Identifier)不能为其他中开发者账号中已经存在的app id</p><h2 id="0x1">0x1</h2><p>不要使用正式的bundle id 进行直接调试,如果app需要上架,并且在开发者网站没有创建appid,调试后,则会造成以后bundle id 已经存在问题</p><h2 id="0x2">0x2</h2><p>苹果最近可能最频繁生成appid进行了限制（详情），7天内不能超过10个，当经常运行一些demo，非正式项目的时候，建议bundle填写或者修改成一个固定的bundle id进行调试，比如我一直在使用org.skyfox.test进行调试，当有新设备的时候fix下就ing了，也是对那些生成乱七八糟证书，profile文件的一个技巧</p><p><img src="https://user-images.githubusercontent.com/16996753/53940048-9bfe3380-40ef-11e9-985b-2be9a5761650.png" alt="image"></p><h2 id="0x3">0x3</h2><p>新项目选择手机为运行目标(更改Deploymnet Target 为适合的版本)后,直接可以run起来,如果是老项目,曾经设置过证书,需要如图配置后生效</p><p>证书选择你的Apple ID 邮箱为名的证书</p><p>选择刚刚生成的Provisioning Profile文件,(文件名为iOSTeam Provisioning Profile:项目的Bundle ID),</p><p><img src="https://user-images.githubusercontent.com/16996753/53940079-b1735d80-40ef-11e9-8d97-08652b2a2000.png" alt="image"></p><p>那么问题来了,电脑中越来越多的Provisioning Profile文件如何管理,神马个人证书,企业证书,乱起八糟的Provisioning Profile</p><p>推荐个Provisioning Profile管理软件 <a href="https://github.com/shaojiankui/ProfilesManager" target="_blank" rel="noopener">https://github.com/shaojiankui/ProfilesManager</a></p><p>很遗憾,目前没有地方管理已经生成的并且存在苹果服务器端的Provisioning Profile文件</p><hr><p>Reference：</p><blockquote><p>GitHub Repo：<a href="https://github.com/CoderTonyChan/CoderTonyChan.github.io" target="_blank" rel="noopener">Tony Studio</a></p><p>Follow: <a href="https://github.com/CoderTonyChan" target="_blank" rel="noopener">CoderTonyCHan · GitHub</a></p></blockquote>]]></content:encoded>
      
      <comments>https://blog.tonystudio.ml/2015/06/12/Xcode-appid/#disqus_thread</comments>
    </item>
    
    <item>
      <title>iOS 9插件</title>
      <link>https://blog.tonystudio.ml/2015/05/06/ios9-collect/</link>
      <guid>https://blog.tonystudio.ml/2015/05/06/ios9-collect/</guid>
      <pubDate>Tue, 05 May 2015 16:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;iOS 9越狱后的重要插件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&quot;应用类&quot;&gt;应用类&lt;/h1&gt;
&lt;h2 id=&quot;phoenix-v4&quot;&gt;Phoenix v4&lt;/h2&gt;
&lt;hr&gt;
&lt;p&gt;成功率很高&lt;/p&gt;
&lt;p&gt;签名是一个问题
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>iOS 9越狱后的重要插件。</p></blockquote><hr><h1 id="应用类">应用类</h1><h2 id="phoenix-v4">Phoenix v4</h2><hr><p>成功率很高</p><p>签名是一个问题 目前存在 兔兔助手 搜索 越狱</p><h2 id="activator">Activator</h2><hr><h3 id="activator自用手势">Activator自用手势</h3><hr><p>支持iOS 9</p><p>①锁屏，在主屏幕，滑出屏幕底部。</p><p>②返回主屏幕，在app中，滑出屏幕底部。</p><p>③打开多任务，在任意位置，从屏幕左下滑向屏幕中心。</p><p>④打开通知中心，在任意位置，从屏幕右下滑向屏幕中心。</p><p>⑤返回键，在app中，触碰一下TouchID指纹。</p><p>⑥截图，在任意位置，触碰两下TouchID指纹。</p><p>⑦黑屏快速解锁，在锁屏界面，触碰一下TouchID指纹。</p><h2 id="app-admin">App Admin</h2><hr><p>支持iOS 9</p><h2 id="reprovsion">Reprovsion</h2><hr><p>支持iOS 9 签名</p><h2 id="icleaner-pro">iCleaner Pro</h2><hr><p>支持iOS 9</p><h2 id="filza-32">Filza 32</h2><hr><p>支持iOS 9</p><h2 id="cydown">Cydown</h2><hr><p>这里可以直接添加源</p><p>比如搜索<br>ppsspp/xarold</p><h2 id="flex-3">Flex 3</h2><hr><p>支持iOS 9</p><h3 id="flexible">FLEXible</h3><hr><p>支持iOS 9</p><h2 id="datamete流量">DataMete流量</h2><hr><p>实时监控数据流量</p><h2 id="anywhere">Anywhere</h2><hr><p>Anywhere这款插件可以轻松修改定位位置和设备机型，显示任意你想显示的地理位置和设备机型。早上在北京，晚上在上海；今天iPhone6，明天iPhone6s；让你在微博、QQ空间上发信息时逼格十足。</p><p>如安装后手机桌面没有出现【虚拟定位】的图标，请使用PP助手【管理】里的【修复图标】功能进行修复。</p><h2 id="flux">f.lux</h2><hr><p>自动调整色温</p><h1 id="springtomize3">Springtomize3</h1><hr><p>全能插件神器</p><p>Springtomize3是一款全能型系统修改的神器！它包括了(动画、多任务显示、控制中心、Dock、文件夹、图标、锁定屏幕、主屏幕页面、状态栏)的修改。Springtomize3（iOS9/8/7）1.4.1-1版本已支持iOS9.3.3越狱！</p><p>之所以被称为“瑞士军刀”，是因为 Springtomize 3 的多合一功能属性，这款来自著名 iOS 开发者 Filippo Bigarella 的作品，几乎成为了越狱用户们的“必装插件”。有了 Springtomize 3，你就不需要到 Cydia 中下载那些功能单一的小插件了。Springtomize 3 可以对 iOS 设备的大量元素进行修改，它囊括的范围之广在越狱插件中也十分罕见。</p><h1 id="virtualhome">VirtualHome</h1><hr><p>模拟物理Home键</p><h1 id="tage">Tage</h1><hr><p>强大的手势插件</p><h1 id="游戏类">游戏类</h1><hr><p>TODO</p><p>整理一些最终停留在iOS 9上的优秀游戏</p><h2 id="几个安装游戏的途径">几个安装游戏的途径</h2><hr><h3 id="爱思越狱版">爱思越狱版</h3><p>–<br>下载破解IPA</p><p>这里的几乎可以用 兔兔那些很多签名是掉了的</p><h3 id="兔兔助手">兔兔助手</h3><h3 id="panda-helper">Panda Helper</h3><h3 id="同步推">同步推</h3><h3 id="pp助手没人维护">PP助手(没人维护</h3><h2 id="海之号角">海之号角</h2><hr><p>IOS上的塞尔达</p><h2 id="ppsspp">PPSSPP</h2><hr><p>1.PPSSPP Cydia/APT <a href="https://cydia.ppsspp.org/" target="_blank" rel="noopener">repository</a></p><p>2.Install PPSSPP using Cydia Impactor</p><h2 id="索尼克全明星赛车">索尼克全明星赛车</h2><hr><p>Sonic &amp; All-Star Racing:Transformed</p><h2 id="无敌士兵糊涂蛋">无敌士兵糊涂蛋</h2><hr><p>Respawnables，号称IOS上的CS</p><h2 id="badland">Badland</h2><hr><p>有1和2，都支持</p><h2 id="stormraiders">StormRaiders</h2><hr><p>3D空战游戏<br>)</p><hr><p>Reference：</p><blockquote><p>GitHub Repo：<a href="https://github.com/CoderTonyChan/CoderTonyChan.github.io" target="_blank" rel="noopener">Tony Studio</a></p><p>Follow: <a href="https://github.com/CoderTonyChan" target="_blank" rel="noopener">CoderTonyCHan · GitHub</a></p></blockquote>]]></content:encoded>
      
      <comments>https://blog.tonystudio.ml/2015/05/06/ios9-collect/#disqus_thread</comments>
    </item>
    
    <item>
      <title>常用软件合集 @ Mac/iOS/Android/Win</title>
      <link>https://blog.tonystudio.ml/2015/02/16/soft-collect/</link>
      <guid>https://blog.tonystudio.ml/2015/02/16/soft-collect/</guid>
      <pubDate>Mon, 16 Feb 2015 02:51:24 GMT</pubDate>
      <description>
      
        
        
          &lt;blockquote&gt;
&lt;p&gt;Mac / iOS / Android 的常用软件 😊 。&lt;br&gt;
可自行搜索一些我提供的关键词 😊 。&lt;br&gt;
下面我们来了解它们的用法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://pn9jzw2t9.bkt
        
      
      </description>
      
      <content:encoded><![CDATA[<blockquote><p>Mac / iOS / Android 的常用软件 😊 。<br>可自行搜索一些我提供的关键词 😊 。<br>下面我们来了解它们的用法。</p></blockquote><p><img src="http://pn9jzw2t9.bkt.clouddn.com/2019/soft-collect.1.jpg" alt=""></p><h1 id="mac">Mac</h1><hr><p>Mac电脑上有很多应用，这里不提供任何安装包，默认是链接到对应的App官网，另外，如果App有上架到AppStore，建议在AppStore购买下载，说不定下次换电脑时会非常方便！</p><h2 id="效率">效率</h2><hr><p>macOS自带的。</p><h3 id="提醒事项">提醒事项</h3><h3 id="邮件">邮件</h3><h3 id="日历">日历</h3><h3 id="系统边栏股票日历">系统边栏(股票/日历)</h3><h3 id="reeder">Reeder</h3><p>配合RSSHub + inoreader 使用</p><h3 id="即时分享airdropsnapdrop">即时分享(AirDrop/<a href="https://snapdrop.net/" target="_blank" rel="noopener">snapdrop</a>)</h3><h3 id="synergy">synergy</h3><p>同时使用2部电脑</p><h3 id="airserver">AirServer</h3><p>AirServer 7.1.4 将Mac变成一个AirPlay终端</p><p>airserver_7.1.4 TNT.dmg</p><h2 id="存储">存储</h2><hr><p>开发工具。</p><h3 id="icloud">iCloud</h3><p>5G</p><h3 id="google-drive">Google Drive</h3><p>图片/视频 无限量 Google Photo的搜索功能更加强大</p><h3 id="one-drive">One Drive</h3><p>5G</p><h3 id="百度云">百度云</h3><p>2T</p><h2 id="ide">IDE</h2><hr><p>开发工具。</p><h3 id="xcode"><a href="https://itunes.apple.com/us/app/xcode/id497799835?mt=12" target="_blank" rel="noopener">Xcode</a></h3><p>Xcode是 Mac, iPhone, iPad, Apple TV, and Apple Watch 等应用的开发集成工具。</p><h3 id="visual-studio-code"><a href="https://code.visualstudio.com/download" target="_blank" rel="noopener">Visual Studio Code</a></h3><!-- ![](https://github.com/iHTCboy/iGallery/raw/master/BlogImages/2018/07/20180715-macOS-Visual_Studio_Code.png)  --><img src="https://github.com/iHTCboy/iGallery/raw/master/BlogImages/2018/07/20180715-macOS-Visual_Studio_Code.png" width="40" height="40" div="" align="left" style=" margin-right: 20px;">Visual Studio Code是一个由微软开发的，同时支持Windows、Linux和macOS操作系统且开放源代码的文本编辑器。它支持调试，并内置了Git 版本控制功能，同时也具有开发环境功能，例如代码补全、代码片段、代码重构等。<h3 id="android-studio"><a href="https://developer.android.com/studio/" target="_blank" rel="noopener">Android Studio</a></h3><p>Android Studio是一个为Android平台开发程序的集成开发环境。</p><h3 id="intellij-idea"><a href="https://www.jetbrains.com/idea/download" target="_blank" rel="noopener">IntelliJ IDEA</a></h3><p>Android Studio是一个为Android平台开发程序的集成开发环境。</p><h3 id="navicat-premium">Navicat Premium</h3><p>Navicat Premium 是一套数据库开发工具，让你从单一应用程序中同时连接 MySQL、MariaDB、SQL Server、Oracle、PostgreSQL 和 SQLite 数据库。它与 Amazon RDS、Amazon Aurora、Amazon Redshift、Microsoft Azure、Oracle Cloud、阿里云和腾讯云等云数据库兼容。你可以快速轻松地创建、管理和维护数据库。</p><h3 id="robo-3t">Robo 3T</h3><h2 id="运维相关command-line-tools">运维相关（COMMAND LINE TOOLS)</h2><h3 id="transmit"><a href="https://panic.com/transmit/" target="_blank" rel="noopener">Transmit</a></h3><img src="https://res.cloudinary.com/hrscywv4p/image/upload/c_limit,fl_lossy,h_9000,w_1200,f_auto,q_auto/v1/1389536/256x256_gwovqc.png" width="40" height="40" div="" align="left" style=" margin-right: 20px;"><br><br>Transmit for mac是一款功能齐全Mac用户必备的FTP客户端。<h3 id="microsoft-remote-desktop">Microsoft Remote Desktop</h3><p>App Store</p><h3 id="homebrew">Homebrew</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure><h3 id="~sshconfig">~/.ssh/config</h3><p>iCloud备份</p><h3 id="gitconfig">.gitconfig</h3><p>iCloud备份</p><h3 id="openssh">OpenSSH</h3><h3 id="docker">Docker</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew cask install docker</span><br></pre></td></tr></table></figure><h3 id="curl">cURL</h3><h3 id="wget">wget</h3><h3 id="adb">adb</h3><h3 id="git"><a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a></h3><p>版本控制工具，官网提供<a href="https://git-scm.com/download/gui/mac" target="_blank" rel="noopener">数十种GUI客户端</a> for Mac。</p><h2 id="抓包">抓包</h2><hr><h3 id="charles">Charles</h3><hr><p>Charles is an HTTP proxy / HTTP monitor / Reverse Proxy that enables a developer to view all of the HTTP and SSL / HTTPS traffic between their machine and the Internet. This includes requests, responses and the HTTP headers (which contain the cookies and caching information).</p><h3 id="mitmproxy"><a href="https://mitmproxy.org/" target="_blank" rel="noopener">mitmproxy</a></h3><hr><p>一款支持HTTP(S)的中间人代理工具，可在终端下运行，可用于抓包</p><h3 id="postman">postman</h3><h3 id="wireshark">Wireshark</h3><hr><p>Wireshark（前称Ethereal）是一个网络封包分析软件。网络封包分析软件的功能是撷取网络封包，并尽可能显示出最为详细的网络封包资料。Wireshark使用WinPCAP作为接口，直接与网卡进行数据报文交换。</p><h3 id="reveal">Reveal</h3><hr><p>Reveal是iOS开发工具中的神器之一，它能够在应用程序运行过程中调试应用程序界面。</p><h2 id="system">SYSTEM</h2><hr><p>增强或改变macOS系统功能，常驻状态栏或成为系统服务的一部分。</p><h3 id="istat-menus-for-mac">iStat Menus for Mac</h3><hr><p>激活码</p><p>Email: <a href="mailto:982092332@qq.com" target="_blank" rel="noopener">982092332@qq.com</a> SN: GAWAE-FCWQ3-P8NYB-C7GF7-NEDRT-Q5DTB-MFZG6-6NEQC-CRMUD-8MZ2K-66SRB-SU8EW-EDLZ9-TGH3S-8SGA</p><h2 id="fliqlo-主题">fliqlo 主题</h2><hr><p>屏保/免费 <a href="https://fliqlo.com" target="_blank" rel="noopener">fliqlo</a></p><h3 id="telegram">Telegram</h3><hr><p>社交</p><h3 id="the-unarchiver">The Unarchiver</h3><hr><p>The Unarchiver是一款免费实用的解压缩应用程序，用户可以使用它解压多达30种不同的压缩格式文件。</p><p>App Store</p><h3 id="microsoft-office">Microsoft Office</h3><hr><h3 id="evernote"><a href="https://evernote.com/" target="_blank" rel="noopener">Evernote</a></h3><hr><p>App Store</p><h3 id="final-cut-pro">Final Cut Pro</h3><hr><p>Final Cut Pro TNT</p><h3 id="adobe">Adobe</h3><hr><p>Adobe Zii.app</p><p>Portraiture+3.0.27%E7%A3%A8%E7%9A%AE%E6%8F%92%E4%BB%B6%E4%B8%AD%E6%96%87%E7%89%88.dmg</p><h3 id="tuxera-ntfs">Tuxera NTFS</h3><p>Tuxera NTFS.zip</p><h3 id="appcleaner">AppCleaner</h3><hr><p>免费</p><h2 id="下载">下载</h2><hr><h3 id="aria2"><a href="https://aria2.github.io/" target="_blank" rel="noopener">aria2</a></h3><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install aria2</span><br></pre></td></tr></table></figure><p>配合 <a href="https://github.com/acgotaku/BaiduExporter" target="_blank" rel="noopener">BaiduExporter</a> 和 UI(YAAW和Aria2 WebUI)使用</p><h3 id="you-get"><a href="https://you-get.org/" target="_blank" rel="noopener">You-Get</a></h3><hr><p>网络富媒体命令行下载工具。</p><h3 id="迅雷"><a href="http://mac.xunlei.com/" target="_blank" rel="noopener">迅雷</a></h3><hr><p>Mac迅雷3.0</p><h2 id="书籍">书籍</h2><h3 id="ibook">iBook</h3><h3 id="kindle">Kindle</h3><h3 id="calibre"><a href="http://calibre-ebook.com/" target="_blank" rel="noopener">Calibre</a></h3><p>Calibre 是一款强大且易用的电子书本地管理工具，可以在 Windows、macOS 和 Linux 平台集中整理各种格式的电子书</p><p><a href="https://github.com/kovidgoyal/calibre" target="_blank" rel="noopener">GitHub</a></p><h3 id="kindle-comic-converter">Kindle Comic Converter</h3><p>Kindle Comic Converter (KCC) 是一个可以把 PNG、JPG、GIF、CBZ、CBR 和 CB7 格式的漫画转换成 EPUB 或 MOBI 格式电子书的免费开源软件，制作 E-Ink 设备适用的电子书从此轻而易举。KCC 最初是专门为 Kindle 所开发的，但是现在对 EPUB 3.0 和 CBZ 也有效。此外 KCC 在处理图片时会针对电子墨水显示屏进行全面优化。</p><p><a href="https://github.com/ciromattia/kcc" target="_blank" rel="noopener">GitHub</a></p><h2 id="影音">影音</h2><h3 id="airplay">Airplay</h3><h3 id="vlc">VLC</h3><h3 id="downie-3">Downie 3</h3><img src="https://www.haven.vip/wp-content/uploads/2018/09/downie-3.png" width="40" height="40" div="" align="left" style=" margin-right: 20px;"><br>Downie 3 for Mac TNT<br><br><h3 id="plex">Plex</h3><p>套装 配合Android TV , 📱 , Kodi用</p><h3 id="kodi">Kodi</h3><p>套装 配合Android TV用</p><h2 id="proxy-ss">Proxy SS</h2><hr><p>你懂的</p><h3 id="shadowsocksx-ng"><a href="https://github.com/shadowsocks/ShadowsocksX-NG" target="_blank" rel="noopener">ShadowsocksX-NG</a></h3><p>Next Generation of <a href="https://github.com/shadowsocks/shadowsocks-iOS" target="_blank" rel="noopener">ShadowsocksX</a></p><h3 id="surge">Surge</h3><p>Surge 2.1.3 TNT .dmg</p><h2 id="插件">插件</h2><hr><p>Safari 和 Chrome的插件</p><h3 id="tampermonkey">Tampermonkey</h3><p><a href="https://tampermonkey.net/" target="_blank" rel="noopener">https://tampermonkey.net/</a></p><h3 id="userscript">Userscript+</h3><p>Userscript+ : 显示当前网站所有可用的UserJS脚本 Jaeger</p><p><a href="https://greasyfork.org/zh-CN/scripts/24508-userscript-show-site-all-userjs" target="_blank" rel="noopener">https://greasyfork.org/zh-CN/scripts/24508-userscript-show-site-all-userjs</a></p><h3 id="cors插件">CORS插件</h3><h3 id="vuereact-开发插件">Vue/React 开发插件</h3><h3 id="postman插件">postman插件</h3><h3 id="json格式化插件">json格式化插件</h3><h3 id="websocket插件">websocket插件</h3><h3 id="aria2和baiduexporter插件">aria2和BaiduExporter插件</h3><h2 id="音乐">音乐</h2><hr><h3 id="ieasemusic-基于网易云音乐"><a href="http://music.163.com/" target="_blank" rel="noopener">ieaseMusic</a> 基于网易云音乐</h3><h1 id="ios">iOS</h1><hr><p>iOS！</p><h2 id="常用">常用</h2><hr><h3 id="照片">照片</h3><hr><p>上传一些共享相簿 / 看一些推荐视频</p><h3 id="shadowrocket-quantumult">Shadowrocket / Quantumult</h3><hr><p>梯子</p><h3 id="jsbox-pin">JSBox / Pin</h3><hr><p>Javbox / Axgle / XList / 小良</p><h3 id="reeder">Reeder</h3><hr><p>Reeder + RSSHub + ino</p><h3 id="捷径">捷径</h3><hr><p>开门(自抓API) + 磁力 + 小良</p><h3 id="米家">米家</h3><hr><p>监控</p><h3 id="图书">图书</h3><hr><p>系统自带</p><h3 id="kindle">Kindle</h3><hr><p>结合Vol.moe + Amaze 服务器使用</p><h3 id="keep-watch">Keep / Watch</h3><hr><p>结合 Apple Watch + 健身记录使用</p><h3 id="家庭">家庭</h3><hr><p>结合 HomeAssient + HomeBridge使用</p><h3 id="豆瓣">豆瓣</h3><hr><p>记录 电影 + 图书 + 游戏 + 音乐?</p><h3 id="one-note">One Note</h3><hr><p>记录</p><h3 id="印象笔记">印象笔记</h3><hr><p>记录</p><h2 id="运维">运维</h2><hr><h3 id="documents">Documents</h3><hr><p>上传下载 就是不支持隐藏文件</p><h3 id="termius">Termius</h3><hr><p>ssh</p><h3 id="cloud-console">Cloud Console</h3><hr><p>Google 云</p><h3 id="远程桌面">远程桌面</h3><hr><p>Google Chrome</p><h2 id="dlna">DLNA</h2><hr><p>影音 基本上Infuse能满足所有需求了 Plex也不需要安装</p><h3 id="infuse">Infuse</h3><hr><p>自动下载海边</p><h3 id="vlc">VLC</h3><hr><p>开源</p><h3 id="videoamptvside">Video&amp;TVSide</h3><hr><p>Sony TV遥控</p><h3 id="迅雷">迅雷</h3><hr><p>需要自签名</p><h2 id="存储">存储</h2><hr><h3 id="文件icloud">文件(iCloud)</h3><hr><p>可以管理所有支持的网盘 (Google / OneDrive / 百度云)</p><h3 id="google-drive">Google Drive</h3><hr><p>免费上传一些 图片和视频 图片的分类还是Google 做得好 而且还能搜索</p><h3 id="onedrive">OneDrive</h3><hr><p>5G 免费硬盘  结合 One Note 使用</p><h3 id="百度云">百度云</h3><hr><p>2T 啥都有</p><h2 id="google-4宝">Google 4宝</h2><hr><h3 id="google-相册">Google 相册</h3><hr><h3 id="google-map">Google Map</h3><hr><h3 id="chrome">Chrome</h3><hr><h3 id="youtube">Youtube</h3><hr><h2 id="社交">社交</h2><hr><h3 id="telegram">Telegram</h3><hr><h3 id="facebook">Facebook</h3><hr><h3 id="instagram">Instagram</h3><hr><h3 id="微博">微博</h3><hr><p>虽然很多用Rss订阅过了</p><h2 id="越狱">越狱</h2><hr><h3 id="ios-9">iOS 9</h3><hr><p><a href="https://mrmad.com.tw/tihmstar-jailbreakme-4-0" target="_blank" rel="noopener">JailbreakMe</a>  <a href="https://mrmad.com.tw" target="_blank" rel="noopener">mrmad</a></p><p><a href="https://mrmad.com.tw/ios-9-3-5-jb-qa" target="_blank" rel="noopener">Phoenix</a>  <a href="https://mrmad.com.tw" target="_blank" rel="noopener">mrmad</a></p><p>Phoenix v4 (2017.12.30)</p><p>tutuapp 搜索 越狱</p><h4 id="更多游戏可看ios-9插件">更多游戏可看<a href="https://blog.tonystudio.ml/2015/05/06/ios9-collect/">iOS 9插件</a></h4><h3 id="ios-10">iOS 10</h3><hr><p><a href="https://mrmad.com.tw/ios10-jailbreakme" target="_blank" rel="noopener">JailbreakMe</a>  <a href="https://mrmad.com.tw" target="_blank" rel="noopener">mrmad</a></p><h3 id="ios-11">iOS 11</h3><hr><p><a href="https://mrmad.com.tw/unc0ver" target="_blank" rel="noopener">unc0ver</a> <a href="https://mrmad.com.tw" target="_blank" rel="noopener">mrmad</a></p><h3 id="ios-12">iOS 12</h3><hr><p><a href="https://mrmad.com.tw/rootlessjb3" target="_blank" rel="noopener">rootlessJB</a> <a href="https://mrmad.com.tw" target="_blank" rel="noopener">mrmad</a></p><p><a href="https://mrmad.com.tw/unc0ver" target="_blank" rel="noopener">unc0ver</a> <a href="https://mrmad.com.tw" target="_blank" rel="noopener">mrmad</a> 也支持了</p><p>配合<a href="https://ipswbeta.com/category/ipa-library/" target="_blank" rel="noopener">ipswbeta</a> 下载ipa</p><p>一些cydia源 信息</p><p><a href="https://www.ios-repo-updates.com/news/" target="_blank" rel="noopener">https://www.ios-repo-updates.com/news/</a></p><p><a href="https://repo.xarold.com" target="_blank" rel="noopener">https://repo.xarold.com</a></p><p>插件</p><ul><li>wechathookpro</li><li>DouTapLock</li><li>WeChatCallKit</li><li>localiapstore</li><li>conditionWIFI3</li><li>flexible</li></ul><p>软件</p><ul><li>iCleanerPro</li><li>Flex 3</li><li>Filza</li><li>Cydown</li><li>HomeGesture (iPhone X以下用)</li></ul><h3 id="flex3">Flex3</h3><hr><p>实现无限下载补丁，解决一天 安装两个的烦恼！<br>账号是sundasheng521@qq.com<br>密码是7758521a</p><ul><li>iPhone X以外 dock拦透明</li><li>各种去广告</li><li>更多请<a href="https://blog.tonystudio.ml/2018/08/06/ios-flex/">参考这里</a></li></ul><h3 id="破解音乐">🎵 破解音乐</h3><hr><p>破解后在网易云音乐下载的音乐 全部带封面 而且信息齐全 不依赖电脑导入音乐</p><p>越狱系统手动导入音乐 互相导入</p><p>路径为/private/var/mobile/Containers/Data/Application/47A730BC-AA9F-4225-A1BC-B024A490EBEC/Documents/UserData/Download/done<br>这是网易云音乐的文件路径，提示 这里是iOS11系统。</p><p>Fliza底部栏有个五星的图标 点击 看到列表里有音乐库这个名称 这就是自带音乐的文件夹了 点击进去然后Fliza底部栏左下角选择粘贴</p><p><img src="https://user-images.githubusercontent.com/16996753/53925578-663f5780-40bb-11e9-948b-5fefa1d17d23.png" alt="image"></p><h3 id="resign">resign</h3><hr><p>resign 只解决了可以重新签证的问题 就算提出IPA 也只是这个机型这个版本的安装包 而且都带签证的(市场上破解游戏基本都带了签证)</p><p>可以使用砸壳软件 比如 CrackerXI 但是大部分都失败 估计底层的API都已经有问题了 (基本失效)</p><p>插件</p><ul><li>Ext3nder (推荐)</li><li>ReProvision (推荐)</li></ul><h3 id="游戏">游戏</h3><hr><p>破解游戏 目前iOS基本都下载带企业签证的 因为这样比较方便 但是也没找到直接下载破解IPA (PP助手)</p><p>我测试 2019</p><ul><li>勇者斗恶龙 123 6 8 可玩</li><li>马里奥 不能</li><li>生化危机 不能</li><li>最终幻想 5 可玩</li><li>Pokemon shuffle 破解版</li></ul><p>目前基本就是四家(2019)</p><ul><li>兔兔助手</li><li>Panda Helper</li><li>爱思助手 (需要win端安装 应用是破解版 省心安装)</li><li>同步推正版 (不推荐 基本正版)</li></ul><h3 id="flex插件">Flex插件</h3><p>一大类 类似油猴 JSBOX 有社交有分享插件 比较通用 比如应用类的去广告 去越狱检测</p><p>利用OC的Hock机制</p><h3 id="爱思ipa问题">爱思/IPA问题</h3><p>用Impactor安裝IPA，頭7後用<a href="https://mrmad.com.tw/ios11-install-ext3nder" target="_blank" rel="noopener">Ext3nder</a> resign</p><p>conditionWIFI3插件，Ext3nder联网权限打开即可完美解决</p><p>爱思会检测签名 分为4类 苹果正版/其他正版/个人正版/共享正版</p><h4 id="苹果正版">苹果正版</h4><hr><p>App Store签名</p><h4 id="其他正版">其他正版</h4><hr><p>企业签名</p><h4 id="个人正版">个人正版</h4><hr><p>Xcode7/2015后 个人7日免费签</p><h4 id="共享正版">共享正版</h4><hr><p>脱壳后 AppSync 免检测</p><h2 id="游戏">游戏</h2><h3 id="r-play-ps4-message">R-play / PS4 Message</h3><h3 id="dq-1-8">DQ 1-8</h3><p>PP助手 越狱版</p><h3 id="小鸡">小鸡</h3><h1 id="android-tv">Android TV</h1><hr><h3 id="termux">Termux</h3><hr><p>APKMirror APKPure</p><h3 id="ssh-server">SSH Server</h3><hr><p>APKMirror APKPure</p><h3 id="pocket-git">Pocket Git</h3><hr><p>Pocket Git APK</p><h3 id="文件管理器">文件管理器+</h3><hr><p>APKMirror APKPure</p><h3 id="es文件浏览器">ES文件浏览器</h3><hr><p>APKMirror APKPure</p><h3 id="shadowsocksr">shadowsocksR</h3><hr><p>shadowsocksR android apk</p><p><a href="https://github.com/shadowsocks/shadowsocks-android/releases" target="_blank" rel="noopener">https://github.com/shadowsocks/shadowsocks-android/releases</a></p><h3 id="plex">Plex</h3><hr><h3 id="kodi">Kodi</h3><hr><h3 id="小鸡">小鸡</h3><hr><h3 id="ppsspp">PPSSPP</h3><hr><h3 id="damonps2">DamonPS2</h3><hr><p>DamonPS2 Pro APK 1.3.3 BIOS</p><p>Version 1.2.1 has cracked, can open without any other space or Lucky Patcher</p><h3 id="麻花影视tv">麻花影视TV</h3><hr><h3 id="吾爱游戏-2019存在">吾爱游戏 (2019存在)</h3><hr><ul><li>马里奥跑酷(APK也闪退)</li></ul><h2 id="android">Android</h2><hr><h3 id="xposed">xposed</h3><hr><p>Hock 类似 Flex3</p><h3 id="magisk">magisk</h3><hr><p><a href="https://www.v2ex.com/t/538220" target="_blank" rel="noopener">https://www.v2ex.com/t/538220</a></p><h1 id="win-10">Win 10</h1><hr><p>KMSpico_setup|小马破解</p><h2 id="系统">系统</h2><hr><p>常用软件</p><h3 id="时间轴win-10-1804版本新功能">时间轴(Win 10 1804版本新功能)</h3><hr><p>能显示浏览器历史</p><h3 id="右边栏">右边栏</h3><hr><p>VPN/投屏/平板模式还是能用一用</p><h3 id="邮件">邮件</h3><hr><p>自带的还是可以用</p><h3 id="照片">照片</h3><hr><p>自带 挺好用 | 自带的照片/电影/音乐/邮件等等客户端都不错 就是edge差一点</p><h3 id="office套装">Office套装</h3><hr><p>KMSpico_setup</p><p>Hock 类似 Flex3</p><h3 id="shadowsocksr-dotnet40">ShadowsocksR-dotnet4.0</h3><hr><p>梯子</p><h3 id="迅雷">迅雷</h3><hr><h3 id="netspeedmonitor-64">NetSpeedMonitor 64</h3><hr><p>显示网速</p><h3 id="winscp">WinSCP</h3><hr><p>ssh工具</p><h3 id="远程桌面">远程桌面</h3><hr><p>自带连接win工具</p><h3 id="powershell">PowerShell</h3><hr><p>自带可以安装 openssh</p><h2 id="microsoft-store">Microsoft Store</h2><hr><p>现在限制权限弄的UWP版本</p><h3 id="uwp版本软件">UWP版本软件</h3><h2 id="游戏">🎮游戏</h2><hr><h3 id="ppsspp">PPSSPP</h3><hr><p>win版比较好</p><h3 id="controller-companion">Controller Companion</h3><hr><p>PS4 手柄🎮连接</p><h3 id="xbox">Xbox</h3><hr><p>暂时没研究</p><h2 id="dlna">DLNA</h2><h3 id="remotr-streamer">Remotr Streamer</h3><p>–<br>串流工具 | N卡公司类似技术</p><h3 id="连接">连接</h3><hr><p>自带投票 | Miracast无线协议</p><h3 id="airserver-core">AirServer Core</h3><hr><p>开源项目</p><h3 id="synergy">Synergy</h3><hr><p>让别人控制</p><h3 id="window-media-player共享视频">Window Media Player共享视频</h3><hr><p>利用自带的DLNA做媒体机</p><h2 id="影音">影音</h2><h3 id="电影和电视">电影和电视</h3><hr><p>自带能用 比以前好多了 Window Media Player 放弃用</p><h3 id="groove-音乐">Groove 音乐</h3><hr><p>能用</p><h3 id="acg播放器">ACG播放器</h3><hr><p>暂时比较好</p><hr><p>Reference：</p><blockquote><p>GitHub Repo：<a href="https://github.com/CoderTonyChan/CoderTonyChan.github.io" target="_blank" rel="noopener">Tony Studio</a></p><p>Follow: <a href="https://github.com/CoderTonyChan" target="_blank" rel="noopener">CoderTonyCHan · GitHub</a></p></blockquote>]]></content:encoded>
      
      <comments>https://blog.tonystudio.ml/2015/02/16/soft-collect/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
